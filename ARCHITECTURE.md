# äº‘æ–‡æ¡£AIç¿»è¯‘å¹³å° - å®Œæ•´æŠ€æœ¯æ¶æ„è®¾è®¡

## ğŸ“‹ ç›®å½•
1. [ç³»ç»Ÿæ¦‚è§ˆ](#ç³»ç»Ÿæ¦‚è§ˆ)
2. [å‰ç«¯æ¶æ„è®¾è®¡](#å‰ç«¯æ¶æ„è®¾è®¡)
3. [åç«¯æ¶æ„è®¾è®¡](#åç«¯æ¶æ„è®¾è®¡)
4. [æ•°æ®åº“è®¾è®¡](#æ•°æ®åº“è®¾è®¡)
5. [ç¬¬ä¸‰æ–¹é›†æˆ](#ç¬¬ä¸‰æ–¹é›†æˆ)
6. [å¼€å‘ä¼˜å…ˆçº§å’Œé‡Œç¨‹ç¢‘](#å¼€å‘ä¼˜å…ˆçº§å’Œé‡Œç¨‹ç¢‘)
7. [æŠ€æœ¯é£é™©å’Œè§£å†³æ–¹æ¡ˆ](#æŠ€æœ¯é£é™©å’Œè§£å†³æ–¹æ¡ˆ)

---

## ç³»ç»Ÿæ¦‚è§ˆ

### æ ¸å¿ƒä»·å€¼ä¸»å¼ 
- æ”¯æŒå¤šæ ¼å¼æ–‡æ¡£ä¸Šä¼ ï¼ˆPDFã€HTMLã€Markdownã€Wordï¼‰
- å®æ—¶ç¿»è¯‘é¢„è§ˆï¼ˆåŒæ é˜…è¯»ç•Œé¢ï¼‰
- æ”¯æŒå¤šä¸ªLLMæœåŠ¡å•†ï¼ˆGeminiã€Claudeã€GPTï¼‰
- æœ¯è¯­åº“ç®¡ç†å’Œä¸€è‡´æ€§æ£€æŸ¥
- ç¿»è¯‘å†å²å’Œç‰ˆæœ¬ç®¡ç†

### æŠ€æœ¯æ ˆæ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å‰ç«¯å±‚ (Browser)                             â”‚
â”‚  Next.js 14 + React 18 + TypeScript + Tailwind CSS/MUI          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    APIç½‘å…³ & æœåŠ¡                               â”‚
â”‚  RESTful API + WebSocket (å®æ—¶ç¿»è¯‘æµ)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      ä¸šåŠ¡é€»è¾‘å±‚                                  â”‚
â”‚  è®¤è¯ | æ–‡æ¡£è§£æ | ç¿»è¯‘ç¼–æ’ | æœ¯è¯­åº“ | å†å²è®°å½•                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      æ•°æ®å±‚                                      â”‚
â”‚  PostgreSQL (ä¸»æ•°æ®) | Redis (ç¼“å­˜) | GCS/S3 (æ–‡ä»¶å­˜å‚¨)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      å¤–éƒ¨é›†æˆ                                    â”‚
â”‚  Google Gemini | Anthropic Claude | OpenAI GPT | OAuth2 Providerâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å‰ç«¯æ¶æ„è®¾è®¡

### 1. é¡¹ç›®ç»“æ„

```
frontend/
â”œâ”€â”€ app/                          # Next.js åº”ç”¨ç›®å½•ç»“æ„
â”‚   â”œâ”€â”€ layout.tsx                # å…¨å±€å¸ƒå±€
â”‚   â”œâ”€â”€ page.tsx                  # é¦–é¡µ
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”œâ”€â”€ layout.tsx            # ä»ªè¡¨æ¿å¸ƒå±€
â”‚   â”‚   â”œâ”€â”€ page.tsx              # ä¸»ç¿»è¯‘ç•Œé¢
â”‚   â”‚   â”œâ”€â”€ history/              # ç¿»è¯‘å†å²é¡µé¢
â”‚   â”‚   â””â”€â”€ terminology/          # æœ¯è¯­åº“ç®¡ç†
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ login/page.tsx        # ç™»å½•é¡µ
â”‚   â”‚   â”œâ”€â”€ register/page.tsx     # æ³¨å†Œé¡µ
â”‚   â”‚   â””â”€â”€ callback/page.tsx     # OAuthå›è°ƒ
â”‚   â”œâ”€â”€ api/                      # APIè·¯ç”±ï¼ˆBFFå±‚ï¼‰
â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ documents/
â”‚   â”‚   â”œâ”€â”€ translations/
â”‚   â”‚   â””â”€â”€ terminology/
â”‚   â””â”€â”€ error.tsx & not-found.tsx # é”™è¯¯é¡µé¢
â”‚
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”œâ”€â”€ Header.tsx            # é¡¶éƒ¨å¯¼èˆª
â”‚   â”‚   â”œâ”€â”€ Sidebar.tsx           # ä¾§è¾¹æ ï¼ˆæ–‡ä»¶åˆ—è¡¨ï¼‰
â”‚   â”‚   â””â”€â”€ Footer.tsx            # åº•éƒ¨
â”‚   â”‚
â”‚   â”œâ”€â”€ editor/
â”‚   â”‚   â”œâ”€â”€ DualPaneEditor.tsx    # åŒæ ç¼–è¾‘å™¨æ ¸å¿ƒç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ SourcePane.tsx        # å·¦æ ï¼ˆåŸæ–‡ï¼‰
â”‚   â”‚   â”œâ”€â”€ TargetPane.tsx        # å³æ ï¼ˆè¯‘æ–‡ï¼‰
â”‚   â”‚   â”œâ”€â”€ EditorToolbar.tsx     # ç¼–è¾‘å·¥å…·æ 
â”‚   â”‚   â””â”€â”€ TranslationStatusBar.tsx # ç¿»è¯‘è¿›åº¦æ¡
â”‚   â”‚
â”‚   â”œâ”€â”€ documents/
â”‚   â”‚   â”œâ”€â”€ DocumentUploader.tsx  # æ–‡ä»¶ä¸Šä¼ ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ UrlInput.tsx          # URLè¾“å…¥ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ DocumentPreview.tsx   # æ–‡æ¡£é¢„è§ˆ
â”‚   â”‚   â””â”€â”€ DocumentList.tsx      # æ–‡æ¡£åˆ—è¡¨
â”‚   â”‚
â”‚   â”œâ”€â”€ translation/
â”‚   â”‚   â”œâ”€â”€ TranslationSettings.tsx  # ç¿»è¯‘è®¾ç½®ï¼ˆLLMé€‰æ‹©ã€è¯­è¨€ã€é£æ ¼ï¼‰
â”‚   â”‚   â”œâ”€â”€ TerminologyPanel.tsx     # æœ¯è¯­åº“é¢æ¿
â”‚   â”‚   â”œâ”€â”€ ContextualMenu.tsx       # å³é”®èœå•ï¼ˆæ®µè½æ“ä½œï¼‰
â”‚   â”‚   â””â”€â”€ SegmentControls.tsx      # æ®µè½çº§åˆ«æ§åˆ¶
â”‚   â”‚
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ Button.tsx, Input.tsx, Modal.tsx  # é€šç”¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ LoadingSpinner.tsx
â”‚   â”‚   â”œâ”€â”€ ErrorBoundary.tsx
â”‚   â”‚   â””â”€â”€ Toast.tsx               # é€šçŸ¥ç»„ä»¶
â”‚   â”‚
â”‚   â””â”€â”€ ai/
â”‚       â”œâ”€â”€ AIProviderSelector.tsx  # LLMé€‰æ‹©å™¨
â”‚       â””â”€â”€ TranslationSuggestion.tsx # ç¿»è¯‘å»ºè®®å¡ç‰‡
â”‚
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api.ts                    # APIå®¢æˆ·ç«¯å·¥å…·ç±»
â”‚   â”œâ”€â”€ auth.ts                   # è®¤è¯é€»è¾‘
â”‚   â”œâ”€â”€ document-parser.ts        # æ–‡æ¡£è§£æï¼ˆå‰ç«¯ä¾§ï¼‰
â”‚   â”œâ”€â”€ storage.ts                # æœ¬åœ°å­˜å‚¨å·¥å…·
â”‚   â”œâ”€â”€ utils.ts                  # é€šç”¨å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ constants.ts              # å¸¸é‡å®šä¹‰
â”‚
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useAuth.ts                # è®¤è¯Hook
â”‚   â”œâ”€â”€ useDocument.ts            # æ–‡æ¡£ç®¡ç†Hook
â”‚   â”œâ”€â”€ useTranslation.ts         # ç¿»è¯‘ä¸šåŠ¡é€»è¾‘Hook
â”‚   â”œâ”€â”€ useTerminology.ts         # æœ¯è¯­åº“Hook
â”‚   â”œâ”€â”€ useWebSocket.ts           # WebSocketè¿æ¥Hook
â”‚   â””â”€â”€ useLocalStorage.ts        # æœ¬åœ°å­˜å‚¨Hook
â”‚
â”œâ”€â”€ store/                        # Zustand çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ auth.store.ts             # è®¤è¯çŠ¶æ€
â”‚   â”œâ”€â”€ document.store.ts         # æ–‡æ¡£çŠ¶æ€
â”‚   â”œâ”€â”€ translation.store.ts      # ç¿»è¯‘çŠ¶æ€
â”‚   â”œâ”€â”€ ui.store.ts               # UIçŠ¶æ€ï¼ˆä¸»é¢˜ã€å¸ƒå±€ç­‰ï¼‰
â”‚   â””â”€â”€ index.ts                  # ç»Ÿä¸€å¯¼å‡º
â”‚
â”œâ”€â”€ types/
â”‚   â”œâ”€â”€ index.ts                  # æ ¸å¿ƒç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ api.ts                    # APIç›¸å…³ç±»å‹
â”‚   â”œâ”€â”€ document.ts               # æ–‡æ¡£ç›¸å…³ç±»å‹
â”‚   â””â”€â”€ translation.ts            # ç¿»è¯‘ç›¸å…³ç±»å‹
â”‚
â”œâ”€â”€ styles/
â”‚   â”œâ”€â”€ globals.css               # å…¨å±€æ ·å¼
â”‚   â”œâ”€â”€ tailwind.config.ts        # Tailwindé…ç½®
â”‚   â””â”€â”€ theme/
â”‚       â”œâ”€â”€ light.ts              # æµ…è‰²ä¸»é¢˜
â”‚       â””â”€â”€ dark.ts               # æ·±è‰²ä¸»é¢˜
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ api.config.ts             # APIç«¯ç‚¹é…ç½®
â”‚   â”œâ”€â”€ ai-providers.config.ts    # AIæœåŠ¡å•†é…ç½®
â”‚   â””â”€â”€ env.ts                    # ç¯å¢ƒå˜é‡éªŒè¯
â”‚
â”œâ”€â”€ middleware.ts                 # Next.js ä¸­é—´ä»¶ï¼ˆè®¤è¯ã€æ—¥å¿—ï¼‰
â”œâ”€â”€ next.config.js                # Next.jsé…ç½®
â”œâ”€â”€ tailwind.config.ts            # Tailwind CSSé…ç½®
â”œâ”€â”€ tsconfig.json                 # TypeScripté…ç½®
â”œâ”€â”€ package.json
â””â”€â”€ .env.local                    # ç¯å¢ƒå˜é‡
```

### 2. åŒæ é˜…è¯»ç•Œé¢ç»„ä»¶è®¾è®¡

#### DualPaneEditor æ ¸å¿ƒç»„ä»¶æ¶æ„

```typescript
// components/editor/DualPaneEditor.tsx
interface DualPaneEditorProps {
  documentId: string;
  sourceLanguage: string;
  targetLanguage: string;
  onTranslationChange: (segmentId: string, translation: string) => void;
}

interface EditorState {
  segments: TranslationSegment[];        // åˆ†å‰²åçš„æ–‡æœ¬æ®µè½
  activeSegmentId: string | null;        // å½“å‰é€‰ä¸­æ®µè½
  syncScroll: boolean;                   // åŒæ æ»šåŠ¨åŒæ­¥
  showComparison: boolean;               // æ˜¾ç¤ºå¯¹æ¯”è§†å›¾
  autoTranslate: boolean;                // è‡ªåŠ¨ç¿»è¯‘
  translationProgress: {
    total: number;
    completed: number;
  };
}

// æ–‡æœ¬åˆ†å‰²ç­–ç•¥
type SegmentStrategy = 'sentence' | 'paragraph' | 'section' | 'custom';

// ç¿»è¯‘æ®µè½æ•°æ®ç»“æ„
interface TranslationSegment {
  id: string;                     // å”¯ä¸€æ ‡è¯†
  sourceText: string;             // åŸæ–‡
  targetText: string;             // è¯‘æ–‡
  type: 'text' | 'heading' | 'code' | 'list' | 'table'; // æ®µè½ç±»å‹
  context?: string;               // ä¸Šä¸‹æ–‡ï¼ˆå‰åæ®µè½ï¼‰
  metadata?: {
    formatting: FormattingInfo;
    terminology: TerminologyMatch[];
    aiSuggestion?: string;
    locked: boolean;              // é”å®šæ®µè½ï¼ˆä¸è‡ªåŠ¨ç¿»è¯‘ï¼‰
  };
}
```

#### å…³é”®è®¾è®¡å†³ç­–

| åŠŸèƒ½ | å®ç°æ–¹æ¡ˆ | åŸå›  |
|------|--------|------|
| **åŒæ åŒæ­¥æ»šåŠ¨** | ä½¿ç”¨Intersection Observer API + ResizeObserver | æ€§èƒ½æ›´ä¼˜ï¼Œæ— éœ€è®¡ç®—æ»šåŠ¨è·ç¦» |
| **æ–‡æœ¬åˆ†å‰²** | å¤šç§ç­–ç•¥ï¼ˆå¥å­/æ®µè½/è‡ªå®šä¹‰ï¼‰ï¼Œåç«¯è¿”å› | å‰åç«¯åä½œï¼Œå‡å°‘å‰ç«¯å¤æ‚åº¦ |
| **å®æ—¶ç¿»è¯‘** | WebSocket + æµå¼ä¼ è¾“ | æå‡ç”¨æˆ·ä½“éªŒï¼Œæ˜¾ç¤ºç¿»è¯‘è¿‡ç¨‹ |
| **æ ·å¼åŒæ­¥** | ä¿ç•™åŸæ–‡æ ¼å¼æ ‡è®°ï¼Œå‰ç«¯æ¸²æŸ“ | æ”¯æŒå¯Œæ–‡æœ¬ï¼ˆåŠ ç²—ã€æ–œä½“ã€é“¾æ¥ç­‰ï¼‰ |
| **æ€§èƒ½ä¼˜åŒ–** | è™šæ‹Ÿæ»šåŠ¨ï¼ˆvirtualizationï¼‰+ æ‡’åŠ è½½ | å¤„ç†å¤§æ–‡æ¡£ï¼ˆ>1000æ®µï¼‰ |

#### ç»„ä»¶å±‚çº§è®¾è®¡

```
DualPaneEditor (å®¹å™¨ç»„ä»¶)
â”œâ”€â”€ EditorToolbar (å·¥å…·æ )
â”‚   â”œâ”€â”€ LLMSelector (AIæœåŠ¡é€‰æ‹©)
â”‚   â”œâ”€â”€ LanguagePair (è¯­è¨€å¯¹é€‰æ‹©)
â”‚   â”œâ”€â”€ SegmentationSelector (åˆ†å‰²ç­–ç•¥)
â”‚   â””â”€â”€ ExportButton (å¯¼å‡º)
â”‚
â”œâ”€â”€ MainContent (ä¸»å†…å®¹åŒº)
â”‚   â”œâ”€â”€ SourcePane (å·¦æ )
â”‚   â”‚   â”œâ”€â”€ VirtualList (è™šæ‹Ÿåˆ—è¡¨)
â”‚   â”‚   â”‚   â””â”€â”€ SegmentItem[] (æ®µè½é¡¹)
â”‚   â”‚   â””â”€â”€ Resizer (è°ƒæ•´å™¨)
â”‚   â”‚
â”‚   â”œâ”€â”€ Resizer (åˆ†å‰²çº¿)
â”‚   â”‚   â””â”€â”€ DragHandle (æ‹–åŠ¨æŠŠæ‰‹)
â”‚   â”‚
â”‚   â””â”€â”€ TargetPane (å³æ )
â”‚       â”œâ”€â”€ VirtualList (è™šæ‹Ÿåˆ—è¡¨)
â”‚       â”‚   â””â”€â”€ EditableSegment[]
â”‚       â”‚       â”œâ”€â”€ TargetText (å¯ç¼–è¾‘)
â”‚       â”‚       â”œâ”€â”€ AISuggestion (å»ºè®®)
â”‚       â”‚       â”œâ”€â”€ TerminologyHints (æœ¯è¯­æç¤º)
â”‚       â”‚       â””â”€â”€ SegmentActions (æ“ä½œ)
â”‚       â””â”€â”€ Resizer
â”‚
â”œâ”€â”€ ContextPanel (ä¾§è¾¹é¢æ¿)
â”‚   â”œâ”€â”€ TerminologyPanel (æœ¯è¯­åº“)
â”‚   â”œâ”€â”€ GlossaryMatches (æœ¯è¯­åŒ¹é…)
â”‚   â””â”€â”€ SegmentHistory (æ®µè½å†å²)
â”‚
â””â”€â”€ TranslationStatusBar (çŠ¶æ€æ )
    â”œâ”€â”€ Progress (è¿›åº¦)
    â”œâ”€â”€ Stats (ç»Ÿè®¡)
    â””â”€â”€ Actions (æ“ä½œæŒ‰é’®)
```

### 3. çŠ¶æ€ç®¡ç†æ–¹æ¡ˆ - Zustand

é€‰æ‹©ç†ç”±ï¼š
- âœ… è½»é‡çº§ï¼ˆ<2KBï¼‰
- âœ… TypeScriptæ”¯æŒå¥½
- âœ… æ— ProvideråµŒå¥—
- âœ… æ”¯æŒä¸­é—´ä»¶å’ŒæŒä¹…åŒ–
- âœ… å­¦ä¹ æ›²çº¿å¹³ç¼“

```typescript
// store/translation.store.ts
import { create } from 'zustand';
import { persist, devtools } from 'zustand/middleware';

interface TranslationStore {
  // çŠ¶æ€
  currentDocument: Document | null;
  segments: TranslationSegment[];
  activeSegmentId: string | null;
  translationProgress: { total: number; completed: number };

  // AIé…ç½®
  selectedLLM: 'gemini' | 'claude' | 'gpt4';
  targetLanguage: string;
  translationStyle: 'formal' | 'casual' | 'technical';
  customPrompt?: string;

  // æœ¯è¯­åº“
  activeTerminologyId: string | null;
  terminologyMatches: Map<string, TermMatch[]>;

  // æ“ä½œ
  setDocument: (doc: Document) => void;
  updateSegment: (id: string, translation: string) => void;
  setActiveSegment: (id: string | null) => void;
  startTranslation: () => void;
  pauseTranslation: () => void;

  // å·¥å…·æ–¹æ³•
  getSegmentContext: (id: string) => { prev?: string; next?: string };
  getTerminologyForSegment: (id: string) => TermMatch[];
}

export const useTranslationStore = create<TranslationStore>()(
  devtools(
    persist(
      (set, get) => ({
        // åˆå§‹çŠ¶æ€
        currentDocument: null,
        segments: [],
        activeSegmentId: null,
        // ... å…¶ä»–åˆå§‹çŠ¶æ€

        // æ“ä½œ
        setDocument: (doc) => set({ currentDocument: doc, segments: [] }),
        updateSegment: (id, translation) =>
          set((state) => ({
            segments: state.segments.map(s =>
              s.id === id ? { ...s, targetText: translation } : s
            ),
          })),
        // ... å…¶ä»–æ“ä½œ

        // å·¥å…·æ–¹æ³•
        getSegmentContext: (id) => {
          const segments = get().segments;
          const index = segments.findIndex(s => s.id === id);
          return {
            prev: index > 0 ? segments[index - 1].sourceText : undefined,
            next: index < segments.length - 1 ? segments[index + 1].sourceText : undefined,
          };
        },
      }),
      {
        name: 'translation-store',
        partialize: (state) => ({
          segments: state.segments,
          translationProgress: state.translationProgress,
        }),
      }
    )
  )
);

// store/document.store.ts - æ–‡æ¡£å­˜å‚¨
// store/auth.store.ts - è®¤è¯å­˜å‚¨
// store/ui.store.ts - UIçŠ¶æ€å­˜å‚¨
```

### 4. UI ç»„ä»¶åº“é€‰æ‹©

#### Tailwind CSS + shadcn/ui æ–¹æ¡ˆï¼ˆæ¨èï¼‰

```
ä¼˜åŠ¿ï¼š
âœ… å¿«é€Ÿå¼€å‘ï¼Œé«˜åº¦å¯å®šåˆ¶
âœ… æ–‡ä»¶å¤§å°å°ï¼Œæ€§èƒ½ä¼˜
âœ… æš—è‰²æ¨¡å¼åŸç”Ÿæ”¯æŒ
âœ… å“åº”å¼è®¾è®¡ç®€æ´
âœ… ç¤¾åŒºæ´»è·ƒï¼Œç»„ä»¶åº“å¤š
âœ… é…åˆ shadcn/ui è·å¾—ç¾è§‚ç»„ä»¶

åŠ£åŠ¿ï¼š
âŒ å­¦ä¹ æ›²çº¿è¾ƒé™¡
âŒ æŸäº›å¤æ‚ç»„ä»¶éœ€è‡ªå·±ç»„åˆ

é…ç½®ç¤ºä¾‹ï¼š
```

```javascript
// tailwind.config.ts
import type { Config } from 'tailwindcss'

export default {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: '#3B82F6',
        secondary: '#8B5CF6',
        brand: {
          light: '#F0F9FF',
          dark: '#0F172A',
        },
      },
      spacing: {
        'editor-gutter': '60px',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
} satisfies Config
```

#### Material-UI å¤‡é€‰æ–¹æ¡ˆ

```
é€‚ç”¨åœºæ™¯ï¼š
- ä¼ä¸šçº§å¤æ‚åº”ç”¨
- éœ€è¦é¢„è®¾å®Œæ•´ç»„ä»¶åº“
- å›¢é˜Ÿç†Ÿæ‚‰Materialè®¾è®¡ç³»ç»Ÿ

æ¨èç»„ä»¶ï¼š
- Drawerï¼ˆä¾§è¾¹æ ï¼‰
- AppBarï¼ˆé¡¶éƒ¨å¯¼èˆªï¼‰
- Tableï¼ˆæœ¯è¯­åº“è¡¨æ ¼ï¼‰
- Dialogï¼ˆç¡®è®¤æ¡†ï¼‰
- Snackbarï¼ˆé€šçŸ¥ï¼‰
```

### 5. æ–‡ä»¶ä¸Šä¼ å’ŒURLè§£æå‰ç«¯å¤„ç†

```typescript
// components/documents/DocumentUploader.tsx
interface DocumentUploaderProps {
  onDocumentSelected: (file: File | string) => Promise<void>;
  supportedFormats: string[];
  maxFileSize: number; // MB
}

// å‰ç«¯å¤„ç†æµç¨‹
const handleFileUpload = async (file: File) => {
  // 1. éªŒè¯
  validateFile(file);

  // 2. æœ¬åœ°é¢„å¤„ç†
  const preview = await generatePreview(file);

  // 3. ä¸Šä¼ åˆ°åç«¯
  const response = await uploadDocument(file);

  // 4. è·å–è§£æç»“æœ
  const parsed = await fetchParsedDocument(response.documentId);

  // 5. åŠ è½½åˆ°ç¼–è¾‘å™¨
  store.setDocument(parsed);
};

const handleUrlInput = async (url: string) => {
  // 1. URLéªŒè¯
  validateUrl(url);

  // 2. åç«¯è¯·æ±‚ï¼ˆæœåŠ¡ç«¯çˆ¬å–ï¼‰
  const response = await api.fetchAndParseUrl(url, {
    targetLanguage: store.targetLanguage,
    strategy: 'cheerio' | 'puppeteer', // ç”±åç«¯å†³ç­–
  });

  // 3. åŠ è½½ç¼–è¾‘å™¨
  store.setDocument(response);
};

// å‰ç«¯åº”è´Ÿè´£çš„éƒ¨åˆ†
const frontendResponsibilities = {
  // âœ… å®¢æˆ·ç«¯éªŒè¯
  validateFile: (file) => {
    if (file.size > MAX_FILE_SIZE) throw new Error('æ–‡ä»¶è¿‡å¤§');
    if (!SUPPORTED_FORMATS.includes(file.type)) throw new Error('æ ¼å¼ä¸æ”¯æŒ');
  },

  // âœ… ç”Ÿæˆé¢„è§ˆï¼ˆå°æ–‡ä»¶ï¼‰
  generatePreview: async (file) => {
    if (file.type === 'application/pdf') return previewPDF(file);
    if (file.type === 'text/html') return previewHTML(file);
    // ...
  },

  // âœ… å¤„ç†ä¸Šä¼ è¿›åº¦
  trackUploadProgress: (event) => {
    const percentage = (event.loaded / event.total) * 100;
    updateProgressBar(percentage);
  },

  // âœ… é”™è¯¯å¤„ç†å’Œé‡è¯•
  uploadWithRetry: async (file, maxRetries = 3) => {
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await uploadDocument(file);
      } catch (error) {
        if (i === maxRetries - 1) throw error;
        await delay(Math.pow(2, i) * 1000); // æŒ‡æ•°é€€é¿
      }
    }
  },
};
```

---

## åç«¯æ¶æ„è®¾è®¡

### 1. æŠ€æœ¯æ ˆé€‰æ‹©

```
è¿è¡Œæ—¶ï¼šNode.js 20 LTS / Python 3.11
æ¡†æ¶ï¼šNest.js (TS) / FastAPI (Python)
æ¨èï¼šNest.jsï¼ˆä¼˜åŠ¿åœ¨äºä¼ä¸šçº§æ”¯æŒã€è£…é¥°å™¨æ¨¡å¼ã€æ·±åº¦é›†æˆï¼‰

ä¸»è¦åŒ…ï¼š
â”œâ”€â”€ @nestjs/core & common         # æ ¸å¿ƒæ¡†æ¶
â”œâ”€â”€ @nestjs/typeorm               # ORMï¼ˆPostgreSQLï¼‰
â”œâ”€â”€ @nestjs/jwt & passport        # è®¤è¯
â”œâ”€â”€ @nestjs/websockets            # WebSocketï¼ˆå®æ—¶ç¿»è¯‘æµï¼‰
â”œâ”€â”€ axios                          # HTTPå®¢æˆ·ç«¯ï¼ˆè°ƒç”¨LLM APIï¼‰
â”œâ”€â”€ openai & @anthropic/sdk       # LLM SDK
â”œâ”€â”€ cheerio & puppeteer           # æ–‡æ¡£çˆ¬å–
â”œâ”€â”€ pdf-parse & docx              # æ–‡æ¡£è§£æ
â”œâ”€â”€ bullmq                         # ä»»åŠ¡é˜Ÿåˆ—
â””â”€â”€ pino                           # æ—¥å¿—
```

### 2. API ç«¯ç‚¹è®¾è®¡ (RESTful)

#### è®¤è¯æ¨¡å—

```
POST   /api/v1/auth/register              æ³¨å†Œç”¨æˆ·
POST   /api/v1/auth/login                 ç”¨æˆ·ç™»å½•
POST   /api/v1/auth/refresh-token         åˆ·æ–°ä»¤ç‰Œ
POST   /api/v1/auth/logout                ç™»å‡º
POST   /api/v1/auth/oauth/google/callback OAuthå›è°ƒ
GET    /api/v1/auth/me                    è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
```

#### æ–‡æ¡£æ¨¡å—

```
POST   /api/v1/documents                  ä¸Šä¼ /åˆ›å»ºæ–‡æ¡£
GET    /api/v1/documents                  åˆ—è¡¨æ–‡æ¡£
GET    /api/v1/documents/:id              è·å–æ–‡æ¡£è¯¦æƒ…
PUT    /api/v1/documents/:id              æ›´æ–°æ–‡æ¡£ä¿¡æ¯
DELETE /api/v1/documents/:id              åˆ é™¤æ–‡æ¡£
GET    /api/v1/documents/:id/content      è·å–è§£æåçš„å†…å®¹
POST   /api/v1/documents/:id/parse        é‡æ–°è§£ææ–‡æ¡£
```

#### ç¿»è¯‘æ¨¡å—

```
POST   /api/v1/translations               åˆ›å»ºç¿»è¯‘ä»»åŠ¡
GET    /api/v1/translations/:id           è·å–ç¿»è¯‘ä»»åŠ¡
PUT    /api/v1/translations/:id/segment   æ›´æ–°å•ä¸ªæ®µè½ç¿»è¯‘
PATCH  /api/v1/translations/:id/status    æ›´æ–°ç¿»è¯‘çŠ¶æ€
POST   /api/v1/translations/:id/export    å¯¼å‡ºç¿»è¯‘ç»“æœ
GET    /api/v1/translations               åˆ—è¡¨ç¿»è¯‘å†å²

WebSocketï¼š
ws://api/v1/translations/:id/stream       å®æ—¶ç¿»è¯‘æµ
```

#### æœ¯è¯­åº“æ¨¡å—

```
POST   /api/v1/terminology-bases          åˆ›å»ºæœ¯è¯­åº“
GET    /api/v1/terminology-bases          åˆ—è¡¨æœ¯è¯­åº“
POST   /api/v1/terminology-bases/:id/terms  æ·»åŠ æœ¯è¯­
GET    /api/v1/terminology-bases/:id/terms  æŸ¥è¯¢æœ¯è¯­
PUT    /api/v1/terminology-bases/:id/terms/:termId  æ›´æ–°æœ¯è¯­
DELETE /api/v1/terminology-bases/:id/terms/:termId  åˆ é™¤æœ¯è¯­
POST   /api/v1/terminology-bases/:id/match     æœ¯è¯­åŒ¹é…API
```

#### å®Œæ•´APIå“åº”è®¾è®¡

```typescript
// æ ‡å‡†å“åº”åŒ…è£…
interface ApiResponse<T> {
  success: boolean;
  code: string;           // 'SUCCESS' | 'VALIDATION_ERROR' | 'UNAUTHORIZED' | ...
  message: string;
  data?: T;
  errors?: FieldError[];
  meta?: {
    timestamp: number;
    traceId: string;
    version: string;
  };
}

interface FieldError {
  field: string;
  message: string;
  code: string;
}

// åˆ†é¡µå“åº”
interface PaginatedResponse<T> {
  items: T[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
  };
}

// ä½¿ç”¨ç¤ºä¾‹
GET /api/v1/translations?page=1&pageSize=20
=>
{
  "success": true,
  "code": "SUCCESS",
  "data": {
    "items": [...],
    "pagination": { ... }
  }
}

POST /api/v1/translations
=>
{
  "success": false,
  "code": "VALIDATION_ERROR",
  "errors": [
    { "field": "targetLanguage", "message": "Invalid language code", "code": "INVALID_ENUM" }
  ]
}
```

### 3. æ–‡æ¡£è§£ææ¨¡å—

#### æ¶æ„è®¾è®¡

```
DocumentParsingService
â”œâ”€â”€ ParseStrategyFactory
â”‚   â”œâ”€â”€ PDFStrategy
â”‚   â”œâ”€â”€ HTMLStrategy
â”‚   â”œâ”€â”€ MarkdownStrategy
â”‚   â”œâ”€â”€ WordStrategy
â”‚   â””â”€â”€ URLStrategy
â”‚
â”œâ”€â”€ TextSegmentationService
â”‚   â”œâ”€â”€ SentenceSegmenter
â”‚   â”œâ”€â”€ ParagraphSegmenter
â”‚   â”œâ”€â”€ SectionSegmenter
â”‚   â””â”€â”€ CustomSegmenter
â”‚
â”œâ”€â”€ FormattingPreserver
â”‚   â”œâ”€â”€ markdownFormatter.preserve()    # ä¿ç•™Markdownæ ¼å¼
â”‚   â”œâ”€â”€ htmlFormatter.convert()          # HTMLè½¬ç»“æ„åŒ–æ ¼å¼
â”‚   â””â”€â”€ codeBlockHandler.extract()       # ä»£ç å—ç‰¹æ®Šå¤„ç†
â”‚
â””â”€â”€ QualityChecker
    â”œâ”€â”€ validateStructure()
    â”œâ”€â”€ detectLanguage()
    â””â”€â”€ estimateComplexity()
```

#### å®ç°ç¤ºä¾‹

```typescript
// services/document-parsing.service.ts
import * as pdf from 'pdf-parse';
import * as cheerio from 'cheerio';
import * as docx from 'docx-parse';

@Injectable()
export class DocumentParsingService {
  async parseDocument(
    file: Buffer,
    format: string,
    options: ParseOptions
  ): Promise<ParsedDocument> {
    const strategy = this.getStrategy(format);
    const rawContent = await strategy.extract(file);

    // ä¿ç•™æ ¼å¼ä¿¡æ¯
    const structured = await this.structureContent(rawContent, format);

    // åˆ†å‰²æ–‡æœ¬
    const segments = await this.segmentText(
      structured.content,
      options.segmentationStrategy
    );

    return {
      id: generateId(),
      title: structured.title,
      language: structured.detectedLanguage,
      segments,
      metadata: structured.metadata,
    };
  }

  private getStrategy(format: string): IParseStrategy {
    switch (format.toLowerCase()) {
      case 'pdf':
        return new PDFStrategy();
      case 'html':
        return new HTMLStrategy();
      case 'markdown':
        return new MarkdownStrategy();
      case 'docx':
        return new WordStrategy();
      default:
        throw new UnsupportedFormatError(format);
    }
  }

  async segmentText(
    content: string,
    strategy: SegmentationStrategy
  ): Promise<TextSegment[]> {
    switch (strategy) {
      case 'sentence':
        return this.segmentBySentence(content);
      case 'paragraph':
        return this.segmentByParagraph(content);
      case 'section':
        return this.segmentBySection(content);
      default:
        return this.segmentByParagraph(content);
    }
  }

  private segmentBySentence(content: string): TextSegment[] {
    // ä½¿ç”¨ nlp åº“å¤„ç†å¤æ‚æ¡ˆä¾‹
    const sentences = content.split(/[.!?]+/).filter(s => s.trim());

    return sentences.map((sentence, idx) => ({
      id: `seg-${idx}`,
      sourceText: sentence.trim(),
      type: 'sentence',
      index: idx,
    }));
  }

  private segmentByParagraph(content: string): TextSegment[] {
    const paragraphs = content
      .split(/\n\n+/)
      .filter(p => p.trim().length > 0);

    return paragraphs.map((para, idx) => ({
      id: `seg-${idx}`,
      sourceText: para.trim(),
      type: 'paragraph',
      index: idx,
    }));
  }
}

// strategies/pdf.strategy.ts
export class PDFStrategy implements IParseStrategy {
  async extract(file: Buffer): Promise<string> {
    const data = await pdf(file);
    return data.text;
  }
}

// strategies/html.strategy.ts
export class HTMLStrategy implements IParseStrategy {
  async extract(file: Buffer): Promise<ParsedHTML> {
    const html = file.toString('utf-8');
    const $ = cheerio.load(html);

    // ç§»é™¤è„šæœ¬å’Œæ ·å¼
    $('script, style').remove();

    // æå–ä¸»è¦å†…å®¹
    const content = this.extractMainContent($);

    return {
      title: $('title').text(),
      content,
      links: $('a').map((_, el) => $(el).attr('href')).get(),
      images: $('img').map((_, el) => $(el).attr('src')).get(),
    };
  }

  private extractMainContent($: any): string {
    // ä¼˜å…ˆä½¿ç”¨ article, main, content æ ‡ç­¾
    const main = $('article, main, [role="main"]').first();
    if (main.length > 0) return main.text();

    // å¦åˆ™æå– body
    return $('body').text();
  }
}

// strategies/markdown.strategy.ts
export class MarkdownStrategy implements IParseStrategy {
  async extract(file: Buffer): Promise<MarkdownParsed> {
    const content = file.toString('utf-8');

    return {
      raw: content,
      ast: parseMarkdownAST(content),
      codeBlocks: this.extractCodeBlocks(content),
      tables: this.extractTables(content),
    };
  }

  private extractCodeBlocks(content: string) {
    const regex = /```(\w+)?\n([\s\S]*?)```/g;
    const blocks = [];
    let match;

    while ((match = regex.exec(content)) !== null) {
      blocks.push({
        language: match[1] || 'text',
        code: match[2],
      });
    }

    return blocks;
  }
}
```

### 4. AI ç¿»è¯‘é›†æˆå±‚

#### å¤šæœåŠ¡å•†æ”¯æŒæ¶æ„

```typescript
// interfaces/ai-provider.interface.ts
export interface IAIProvider {
  name: 'gemini' | 'claude' | 'gpt4';

  translate(
    text: string,
    options: TranslationOptions
  ): Promise<string>;

  translateStream(
    text: string,
    options: TranslationOptions
  ): AsyncIterable<string>;

  getModels(): string[];

  validateCredentials(): Promise<boolean>;

  estimateCost(text: string): EstimatedCost;
}

// services/ai-translation.service.ts
@Injectable()
export class AITranslationService {
  private providers: Map<string, IAIProvider> = new Map();

  constructor(
    private geminiProvider: GeminiProvider,
    private claudeProvider: ClaudeProvider,
    private openaiProvider: OpenAIProvider,
  ) {
    this.providers.set('gemini', geminiProvider);
    this.providers.set('claude', claudeProvider);
    this.providers.set('gpt4', openaiProvider);
  }

  async translate(
    segments: TextSegment[],
    config: TranslationConfig
  ): Promise<TranslationResult[]> {
    const provider = this.getProvider(config.provider);

    // æ„å»ºä¼˜åŒ–çš„æç¤ºè¯
    const prompt = this.buildTranslationPrompt(segments, config);

    // åº”ç”¨æœ¯è¯­åº“çº¦æŸ
    const constrainedPrompt = this.applyTerminologyConstraints(
      prompt,
      config.terminologyId
    );

    // è°ƒç”¨ç¿»è¯‘
    const results = [];
    for (const segment of segments) {
      const translation = await provider.translate(
        segment.sourceText,
        {
          ...config,
          context: this.getSegmentContext(segment),
        }
      );

      results.push({
        segmentId: segment.id,
        sourceText: segment.sourceText,
        targetText: translation,
        provider: config.provider,
        model: config.model,
      });
    }

    return results;
  }

  async *translateStream(
    segment: TextSegment,
    config: TranslationConfig
  ): AsyncIterable<string> {
    const provider = this.getProvider(config.provider);

    const prompt = this.buildTranslationPrompt([segment], config);

    for await (const chunk of provider.translateStream(
      segment.sourceText,
      { ...config, context: this.getSegmentContext(segment) }
    )) {
      yield chunk;
    }
  }

  private buildTranslationPrompt(
    segments: TextSegment[],
    config: TranslationConfig
  ): string {
    const style = config.translationStyle || 'neutral';
    const domain = config.domain || 'general';

    return `
You are a professional translator specializing in ${domain} content.

Target Language: ${config.targetLanguage}
Translation Style: ${style}
${config.customInstructions ? `Custom Instructions:\n${config.customInstructions}` : ''}

Text to translate:
${segments.map(s => s.sourceText).join('\n\n')}

Provide accurate, natural translations maintaining the original formatting and meaning.
${config.preserveFormatting ? 'Preserve all formatting (bold, italic, links, etc.).' : ''}
`;
  }

  private async applyTerminologyConstraints(
    prompt: string,
    terminologyId: string
  ): Promise<string> {
    if (!terminologyId) return prompt;

    const terms = await this.getTerminology(terminologyId);

    const glossary = terms
      .map(t => `${t.source} â†’ ${t.target}`)
      .join('\n');

    return `${prompt}

GLOSSARY (MUST USE):
${glossary}
`;
  }

  private getSegmentContext(segment: TextSegment) {
    // è¿”å›å‰åæ®µè½ï¼Œå¸®åŠ©AIç†è§£ä¸Šä¸‹æ–‡
    return {
      text: segment.sourceText,
      precedingSegments: [],  // å®ç°ä¸­ä»å­˜å‚¨è·å–
      followingSegments: [],
    };
  }

  private getProvider(name: string): IAIProvider {
    const provider = this.providers.get(name);
    if (!provider) throw new UnsupportedProviderError(name);
    return provider;
  }
}

// providers/gemini.provider.ts
export class GeminiProvider implements IAIProvider {
  private client: GoogleGenerativeAI;

  constructor(apiKey: string) {
    this.client = new GoogleGenerativeAI(apiKey);
  }

  async translate(
    text: string,
    options: TranslationOptions
  ): Promise<string> {
    const model = this.client.getGenerativeModel({
      model: options.model || 'gemini-pro'
    });

    const result = await model.generateContent({
      contents: [{
        role: 'user',
        parts: [{ text: options.prompt || text }],
      }],
      generationConfig: {
        maxOutputTokens: 2048,
        temperature: 0.3,  // ç¿»è¯‘åº”è¯¥æ˜¯ç¡®å®šæ€§çš„
      },
      safetySettings: [
        {
          category: HarmCategory.HARM_CATEGORY_UNSPECIFIED,
          threshold: HarmBlockThreshold.BLOCK_NONE,
        },
      ],
    });

    return result.response.text();
  }

  async *translateStream(
    text: string,
    options: TranslationOptions
  ): AsyncIterable<string> {
    const model = this.client.getGenerativeModel({
      model: options.model || 'gemini-pro'
    });

    const stream = await model.generateContentStream(
      options.prompt || text
    );

    for await (const event of stream.stream) {
      const chunk = event.candidates?.[0]?.content?.parts?.[0]?.text;
      if (chunk) yield chunk;
    }
  }

  getModels(): string[] {
    return ['gemini-pro', 'gemini-pro-vision'];
  }

  async validateCredentials(): Promise<boolean> {
    try {
      const model = this.client.getGenerativeModel({ model: 'gemini-pro' });
      await model.generateContent('Test');
      return true;
    } catch {
      return false;
    }
  }

  estimateCost(text: string): EstimatedCost {
    const inputTokens = Math.ceil(text.length / 4);
    const outputTokens = Math.ceil(text.length / 3); // ä¼°è®¡

    return {
      input: inputTokens * 0.000125,   // Gemini Pro è¾“å…¥ä»·æ ¼
      output: outputTokens * 0.000375, // Gemini Pro è¾“å‡ºä»·æ ¼
      total: (inputTokens * 0.000125) + (outputTokens * 0.000375),
    };
  }
}

// providers/claude.provider.ts
export class ClaudeProvider implements IAIProvider {
  private client: Anthropic;

  constructor(apiKey: string) {
    this.client = new Anthropic({ apiKey });
  }

  async translate(text: string, options: TranslationOptions): Promise<string> {
    const response = await this.client.messages.create({
      model: options.model || 'claude-3-sonnet-20240229',
      max_tokens: 2048,
      temperature: 0.3,
      messages: [
        {
          role: 'user',
          content: options.prompt || text,
        },
      ],
    });

    return response.content
      .filter(block => block.type === 'text')
      .map(block => (block as any).text)
      .join('');
  }

  async *translateStream(
    text: string,
    options: TranslationOptions
  ): AsyncIterable<string> {
    const stream = await this.client.messages.stream({
      model: options.model || 'claude-3-sonnet-20240229',
      max_tokens: 2048,
      temperature: 0.3,
      messages: [
        {
          role: 'user',
          content: options.prompt || text,
        },
      ],
    });

    for await (const chunk of stream) {
      if (chunk.type === 'content_block_delta' && chunk.delta.type === 'text_delta') {
        yield chunk.delta.text;
      }
    }
  }

  getModels(): string[] {
    return [
      'claude-3-opus-20240229',
      'claude-3-sonnet-20240229',
      'claude-3-haiku-20240307',
    ];
  }

  async validateCredentials(): Promise<boolean> {
    try {
      await this.client.messages.create({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 100,
        messages: [{ role: 'user', content: 'test' }],
      });
      return true;
    } catch {
      return false;
    }
  }

  estimateCost(text: string): EstimatedCost {
    // Claude pricing varies by model, using Claude 3 Sonnet as default
    const inputTokens = Math.ceil(text.length / 4);
    const outputTokens = Math.ceil(text.length / 3);

    return {
      input: inputTokens * 0.003,     // è¾“å…¥
      output: outputTokens * 0.015,   // è¾“å‡º
      total: (inputTokens * 0.003) + (outputTokens * 0.015),
    };
  }
}

// providers/openai.provider.ts
export class OpenAIProvider implements IAIProvider {
  private client: OpenAI;

  constructor(apiKey: string) {
    this.client = new OpenAI({ apiKey });
  }

  async translate(text: string, options: TranslationOptions): Promise<string> {
    const response = await this.client.chat.completions.create({
      model: options.model || 'gpt-4-turbo-preview',
      messages: [
        {
          role: 'user',
          content: options.prompt || text,
        },
      ],
      temperature: 0.3,
      max_tokens: 2048,
    });

    return response.choices[0].message.content || '';
  }

  async *translateStream(
    text: string,
    options: TranslationOptions
  ): AsyncIterable<string> {
    const stream = await this.client.chat.completions.create({
      model: options.model || 'gpt-4-turbo-preview',
      messages: [
        {
          role: 'user',
          content: options.prompt || text,
        },
      ],
      temperature: 0.3,
      max_tokens: 2048,
      stream: true,
    });

    for await (const chunk of stream) {
      yield chunk.choices[0]?.delta?.content || '';
    }
  }

  getModels(): string[] {
    return [
      'gpt-4-turbo-preview',
      'gpt-4',
      'gpt-3.5-turbo',
    ];
  }

  async validateCredentials(): Promise<boolean> {
    try {
      await this.client.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: 'test' }],
        max_tokens: 10,
      });
      return true;
    } catch {
      return false;
    }
  }

  estimateCost(text: string): EstimatedCost {
    // GPT-4 pricing
    const inputTokens = Math.ceil(text.length / 4);
    const outputTokens = Math.ceil(text.length / 3);

    return {
      input: inputTokens * 0.03,
      output: outputTokens * 0.06,
      total: (inputTokens * 0.03) + (outputTokens * 0.06),
    };
  }
}
```

### 5. æœ¯è¯­åº“ç³»ç»Ÿ

```typescript
// entities/terminology.entity.ts
@Entity('terminology_bases')
export class TerminologyBase {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  userId: string;

  @Column()
  name: string; // æœ¯è¯­åº“åç§°

  @Column('text', { nullable: true })
  description: string;

  @Column({ type: 'varchar', length: 20, default: 'private' })
  visibility: 'private' | 'shared' | 'public'; // å¯è§æ€§

  @OneToMany(() => Term, term => term.terminologyBase, { cascade: true })
  terms: Term[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

@Entity('terms')
export class Term {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @ManyToOne(() => TerminologyBase, term => term.terms, { onDelete: 'CASCADE' })
  terminologyBase: TerminologyBase;

  @Column()
  sourceLanguage: string;

  @Column()
  targetLanguage: string;

  @Column()
  sourceText: string; // åŸæ–‡æœ¯è¯­

  @Column()
  targetText: string; // ç¿»è¯‘æœ¯è¯­

  @Column('text', { nullable: true })
  context?: string; // ç”¨æ³•ç¤ºä¾‹

  @Column('text', { nullable: true })
  notes?: string; // å¤‡æ³¨

  @Column({ type: 'float', default: 0 })
  frequency: number; // ä½¿ç”¨é¢‘ç‡ï¼ˆç”¨äºæ’åºï¼‰

  @Column({ type: 'int', default: 0 })
  usageCount: number; // ä½¿ç”¨æ¬¡æ•°ç»Ÿè®¡

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

// services/terminology.service.ts
@Injectable()
export class TerminologyService {
  constructor(
    private readonly termRepo: Repository<Term>,
    private readonly baseRepo: Repository<TerminologyBase>,
  ) {}

  // åˆ›å»ºæœ¯è¯­åº“
  async createTerminologyBase(
    userId: string,
    dto: CreateTerminologyBaseDto
  ): Promise<TerminologyBase> {
    const base = this.baseRepo.create({
      userId,
      ...dto,
    });
    return this.baseRepo.save(base);
  }

  // æ·»åŠ æœ¯è¯­
  async addTerm(
    baseId: string,
    dto: CreateTermDto
  ): Promise<Term> {
    const term = this.termRepo.create({
      terminologyBase: { id: baseId },
      ...dto,
    });
    return this.termRepo.save(term);
  }

  // æœ¯è¯­åŒ¹é…ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰
  async matchTerms(
    text: string,
    baseId: string,
    options?: { sourceLanguage?: string; targetLanguage?: string }
  ): Promise<TermMatch[]> {
    const terms = await this.termRepo.find({
      where: {
        terminologyBase: { id: baseId },
        ...(options?.sourceLanguage && { sourceLanguage: options.sourceLanguage }),
        ...(options?.targetLanguage && { targetLanguage: options.targetLanguage }),
      },
    });

    const matches: TermMatch[] = [];

    for (const term of terms) {
      // ç²¾ç¡®åŒ¹é…
      if (text.includes(term.sourceText)) {
        matches.push({
          term,
          matchType: 'exact',
          confidence: 1.0,
        });
      }
      // æ¨¡ç³ŠåŒ¹é…ï¼ˆLevenshteinè·ç¦»ï¼‰
      else if (this.fuzzyMatch(text, term.sourceText, 0.8)) {
        matches.push({
          term,
          matchType: 'fuzzy',
          confidence: this.calculateSimilarity(text, term.sourceText),
        });
      }
    }

    // æŒ‰ç½®ä¿¡åº¦æ’åº
    return matches.sort((a, b) => b.confidence - a.confidence);
  }

  private fuzzyMatch(source: string, target: string, threshold: number): boolean {
    const distance = this.levenshteinDistance(source.toLowerCase(), target.toLowerCase());
    const maxLength = Math.max(source.length, target.length);
    const similarity = 1 - (distance / maxLength);
    return similarity >= threshold;
  }

  private levenshteinDistance(s1: string, s2: string): number {
    const len1 = s1.length;
    const len2 = s2.length;
    const matrix: number[][] = [];

    for (let i = 0; i <= len2; i++) {
      matrix[i] = [i];
    }
    for (let j = 0; j <= len1; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= len2; i++) {
      for (let j = 1; j <= len1; j++) {
        if (s2[i - 1] === s1[j - 1]) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }

    return matrix[len2][len1];
  }

  private calculateSimilarity(s1: string, s2: string): number {
    const distance = this.levenshteinDistance(s1.toLowerCase(), s2.toLowerCase());
    const maxLength = Math.max(s1.length, s2.length);
    return 1 - (distance / maxLength);
  }

  // æ‰¹é‡å¯¼å…¥æœ¯è¯­
  async importTerms(
    baseId: string,
    file: Express.Multer.File
  ): Promise<{ imported: number; failed: number }> {
    const text = file.buffer.toString('utf-8');
    const lines = text.split('\n');

    let imported = 0;
    let failed = 0;

    for (const line of lines) {
      const [source, target, context] = line.split('\t');
      if (!source || !target) {
        failed++;
        continue;
      }

      try {
        await this.addTerm(baseId, {
          sourceText: source,
          targetText: target,
          context,
        });
        imported++;
      } catch {
        failed++;
      }
    }

    return { imported, failed };
  }

  // å¯¼å‡ºæœ¯è¯­åº“
  async exportTerms(baseId: string, format: 'csv' | 'json'): Promise<string> {
    const terms = await this.termRepo.find({
      where: { terminologyBase: { id: baseId } },
    });

    if (format === 'csv') {
      const csv = [
        'Source,Target,Context,Notes',
        ...terms.map(t =>
          `"${t.sourceText}","${t.targetText}","${t.context || ''}","${t.notes || ''}"`
        ),
      ].join('\n');
      return csv;
    } else {
      return JSON.stringify(terms, null, 2);
    }
  }
}
```

### 6. ç”¨æˆ·è®¤è¯å’Œå†å²è®°å½•ç®¡ç†

```typescript
// strategies/jwt.strategy.ts
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_SECRET'),
    });
  }

  validate(payload: JwtPayload) {
    return {
      userId: payload.sub,
      email: payload.email,
      roles: payload.roles,
    };
  }
}

// services/auth.service.ts
@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
  ) {}

  async register(dto: RegisterDto): Promise<AuthResponse> {
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    const existing = await this.userService.findByEmail(dto.email);
    if (existing) {
      throw new BadRequestException('ç”¨æˆ·å·²å­˜åœ¨');
    }

    // åˆ›å»ºç”¨æˆ·
    const user = await this.userService.create({
      email: dto.email,
      password: await this.hashPassword(dto.password),
      name: dto.name,
    });

    return this.generateTokens(user);
  }

  async login(email: string, password: string): Promise<AuthResponse> {
    const user = await this.userService.findByEmail(email);
    if (!user) {
      throw new UnauthorizedException('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    const isPasswordValid = await this.verifyPassword(password, user.password);
    if (!isPasswordValid) {
      throw new UnauthorizedException('å¯†ç é”™è¯¯');
    }

    return this.generateTokens(user);
  }

  async validateOAuthUser(
    provider: string,
    profile: any
  ): Promise<User> {
    let user = await this.userService.findByOAuthProvider(provider, profile.id);

    if (!user) {
      user = await this.userService.create({
        email: profile.emails?.[0]?.value || `${profile.id}@${provider}.local`,
        name: profile.displayName,
        oauthProvider: provider,
        oauthId: profile.id,
      });
    }

    return user;
  }

  private generateTokens(user: User): AuthResponse {
    const payload = {
      sub: user.id,
      email: user.email,
      roles: user.roles,
    };

    const accessToken = this.jwtService.sign(payload, {
      expiresIn: '1h',
    });

    const refreshToken = this.jwtService.sign(payload, {
      expiresIn: '7d',
      secret: this.configService.get('JWT_REFRESH_SECRET'),
    });

    return {
      accessToken,
      refreshToken,
      user: { id: user.id, email: user.email, name: user.name },
    };
  }

  private async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, 10);
  }

  private async verifyPassword(
    password: string,
    hash: string
  ): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }
}

// entities/translation-history.entity.ts
@Entity('translation_histories')
export class TranslationHistory {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  userId: string;

  @Column()
  documentId: string;

  @Column()
  documentTitle: string;

  @Column({ length: 10 })
  sourceLanguage: string;

  @Column({ length: 10 })
  targetLanguage: string;

  @Column({ type: 'text' })
  sourceContent: string; // åŸæ–‡å¿«ç…§

  @Column({ type: 'text' })
  targetContent: string; // è¯‘æ–‡å¿«ç…§

  @Column()
  provider: string; // ä½¿ç”¨çš„AIæœåŠ¡å•†

  @Column()
  model: string; // ä½¿ç”¨çš„AIæ¨¡å‹

  @Column({ type: 'int' })
  totalSegments: number;

  @Column({ type: 'int' })
  translatedSegments: number;

  @Column({ type: 'float' })
  estimatedCost: number; // é¢„ä¼°è´¹ç”¨

  @Column({ type: 'jsonb', nullable: true })
  metadata?: {
    segmentationStrategy: string;
    translationStyle: string;
    terminologyUsed: boolean;
  };

  @Column({ type: 'varchar', default: 'completed' })
  status: 'pending' | 'in_progress' | 'completed' | 'failed';

  @Column({ type: 'text', nullable: true })
  errorMessage?: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

// services/translation-history.service.ts
@Injectable()
export class TranslationHistoryService {
  constructor(
    private readonly historyRepo: Repository<TranslationHistory>,
  ) {}

  async recordTranslation(
    userId: string,
    data: CreateTranslationHistoryDto
  ): Promise<TranslationHistory> {
    const history = this.historyRepo.create({
      userId,
      ...data,
    });
    return this.historyRepo.save(history);
  }

  async getHistory(
    userId: string,
    page: number = 1,
    pageSize: number = 20
  ): Promise<PaginatedResult<TranslationHistory>> {
    const [items, total] = await this.historyRepo.findAndCount({
      where: { userId },
      order: { createdAt: 'DESC' },
      skip: (page - 1) * pageSize,
      take: pageSize,
    });

    return {
      items,
      total,
      page,
      pageSize,
    };
  }

  async getHistoryDetail(
    userId: string,
    historyId: string
  ): Promise<TranslationHistory> {
    const history = await this.historyRepo.findOne({
      where: { id: historyId, userId },
    });

    if (!history) {
      throw new NotFoundException('ç¿»è¯‘è®°å½•ä¸å­˜åœ¨');
    }

    return history;
  }

  async getStatistics(userId: string): Promise<UserStatistics> {
    const histories = await this.historyRepo.find({
      where: { userId, status: 'completed' },
    });

    return {
      totalTranslations: histories.length,
      totalSegments: histories.reduce((sum, h) => sum + h.totalSegments, 0),
      totalCost: histories.reduce((sum, h) => sum + h.estimatedCost, 0),
      languagePairs: this.groupLanguagePairs(histories),
      providers: this.groupProviders(histories),
    };
  }

  private groupLanguagePairs(histories: TranslationHistory[]) {
    const pairs = new Map<string, number>();

    for (const history of histories) {
      const key = `${history.sourceLanguage}-${history.targetLanguage}`;
      pairs.set(key, (pairs.get(key) || 0) + 1);
    }

    return Array.from(pairs.entries()).map(([key, count]) => ({
      pair: key,
      count,
    }));
  }

  private groupProviders(histories: TranslationHistory[]) {
    const providers = new Map<string, number>();

    for (const history of histories) {
      providers.set(history.provider, (providers.get(history.provider) || 0) + 1);
    }

    return Array.from(providers.entries()).map(([provider, count]) => ({
      provider,
      count,
    }));
  }
}
```

---

## æ•°æ®åº“è®¾è®¡

### 1. PostgreSQL Schema

```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  name VARCHAR(255),
  avatar_url TEXT,
  oauth_provider VARCHAR(50),
  oauth_id VARCHAR(255),

  -- è®¢é˜…ä¿¡æ¯
  subscription_tier VARCHAR(50) DEFAULT 'free', -- free, pro, enterprise
  subscription_start_date TIMESTAMP,
  subscription_end_date TIMESTAMP,
  monthly_translation_limit INT DEFAULT 10000, -- å…è´¹ç‰ˆæ¯æœˆ10kæ®µè½
  monthly_translation_used INT DEFAULT 0,

  -- é¦–é€‰é¡¹
  default_language_pair JSONB, -- {"source": "en", "target": "zh"}
  preferred_ai_provider VARCHAR(50),
  theme VARCHAR(20) DEFAULT 'light',

  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_email (email),
  INDEX idx_created_at (created_at)
);

-- æ–‡æ¡£è¡¨
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  title VARCHAR(255) NOT NULL,
  description TEXT,
  file_url TEXT,          -- GCS/S3 URL
  file_size INT,          -- å­—èŠ‚
  file_format VARCHAR(50), -- pdf, html, md, docx
  detected_language VARCHAR(10),

  -- è§£æåçš„å†…å®¹ï¼ˆå­˜å‚¨ç»“æ„åŒ–æ•°æ®ï¼‰
  parsed_content JSONB,   -- { "segments": [...], "metadata": {...} }
  content_hash VARCHAR(64), -- ç”¨äºå»é‡

  status VARCHAR(50) DEFAULT 'uploaded', -- uploaded, parsing, parsed, failed
  error_message TEXT,

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP, -- è½¯åˆ é™¤

  INDEX idx_user_id (user_id),
  INDEX idx_created_at (created_at),
  INDEX idx_status (status)
);

-- ç¿»è¯‘ä»»åŠ¡è¡¨
CREATE TABLE translation_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,

  -- ç¿»è¯‘é…ç½®
  source_language VARCHAR(10) NOT NULL,
  target_language VARCHAR(10) NOT NULL,
  ai_provider VARCHAR(50) NOT NULL, -- gemini, claude, gpt4
  ai_model VARCHAR(100),
  translation_style VARCHAR(50), -- formal, casual, technical
  custom_instructions TEXT,

  -- æœ¯è¯­åº“
  terminology_base_id UUID REFERENCES terminology_bases(id),
  preserve_formatting BOOLEAN DEFAULT TRUE,

  -- è¿›åº¦
  status VARCHAR(50) DEFAULT 'pending', -- pending, in_progress, completed, failed
  total_segments INT,
  translated_segments INT DEFAULT 0,
  progress_percentage FLOAT DEFAULT 0,

  -- æˆæœ¬è¿½è¸ª
  estimated_cost DECIMAL(10, 4),
  actual_cost DECIMAL(10, 4),

  -- æ—¶é—´
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_user_id (user_id),
  INDEX idx_status (status),
  INDEX idx_created_at (created_at)
);

-- ç¿»è¯‘æ®µè½è¡¨ï¼ˆæ ¸å¿ƒè¡¨ï¼‰
CREATE TABLE translation_segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES translation_tasks(id) ON DELETE CASCADE,
  document_id UUID NOT NULL REFERENCES documents(id),

  segment_index INT NOT NULL, -- æ®µè½é¡ºåº
  source_text TEXT NOT NULL,
  target_text TEXT,

  -- æ®µè½ä¿¡æ¯
  segment_type VARCHAR(50), -- text, heading, code, list, table
  locked BOOLEAN DEFAULT FALSE, -- é”å®šä¸ç¿»è¯‘

  -- AIå»ºè®®
  ai_suggestion TEXT,
  suggestion_model VARCHAR(100),
  suggestion_quality_score FLOAT, -- 0-1

  -- äººå·¥ç¼–è¾‘
  edited_by_user BOOLEAN DEFAULT FALSE,
  edited_at TIMESTAMP,
  edit_history JSONB, -- ç¼–è¾‘å†å²è®°å½•

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_task_id (task_id),
  INDEX idx_segment_index (task_id, segment_index),
  UNIQUE (task_id, segment_index)
);

-- æœ¯è¯­åº“è¡¨
CREATE TABLE terminology_bases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  name VARCHAR(255) NOT NULL,
  description TEXT,
  visibility VARCHAR(50) DEFAULT 'private', -- private, shared, public

  source_language VARCHAR(10),
  target_language VARCHAR(10),

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_user_id (user_id),
  INDEX idx_name (name)
);

-- æœ¯è¯­è¡¨
CREATE TABLE terms (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  terminology_base_id UUID NOT NULL REFERENCES terminology_bases(id) ON DELETE CASCADE,

  source_text VARCHAR(500) NOT NULL,
  target_text VARCHAR(500) NOT NULL,
  context TEXT, -- ä½¿ç”¨ç¤ºä¾‹
  notes TEXT,

  frequency FLOAT DEFAULT 0, -- ä½¿ç”¨é¢‘ç‡
  usage_count INT DEFAULT 0,

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_terminology_id (terminology_base_id),
  INDEX idx_source_text (source_text),
  INDEX idx_usage_count (usage_count DESC)
);

-- ç¿»è¯‘å†å²è¡¨
CREATE TABLE translation_histories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  task_id UUID REFERENCES translation_tasks(id),

  document_title VARCHAR(255),
  source_language VARCHAR(10),
  target_language VARCHAR(10),

  source_content_snapshot TEXT,
  target_content_snapshot TEXT,

  ai_provider VARCHAR(50),
  ai_model VARCHAR(100),

  total_segments INT,
  translated_segments INT,
  estimated_cost DECIMAL(10, 4),

  status VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_user_id (user_id),
  INDEX idx_created_at (created_at)
);

-- ç”¨æˆ·æ´»åŠ¨æ—¥å¿—è¡¨ï¼ˆå®¡è®¡ï¼‰
CREATE TABLE user_activity_logs (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,

  action VARCHAR(100),
  resource_type VARCHAR(50), -- document, translation, terminology
  resource_id UUID,

  details JSONB,
  ip_address INET,
  user_agent TEXT,

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_user_id (user_id),
  INDEX idx_created_at (created_at)
);
```

### 2. ç¼“å­˜ç­–ç•¥ - Redis

```typescript
// cache/redis.config.ts
import { CacheModule } from '@nestjs/cache-manager';
import * as redisStore from 'cache-manager-redis-store';

export const cacheConfig = CacheModule.register({
  store: redisStore,
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
  ttl: 3600, // é»˜è®¤1å°æ—¶
  auth_pass: process.env.REDIS_PASSWORD,
});

// ç¼“å­˜é”®è®¾è®¡
export const CacheKeys = {
  // ç”¨æˆ·ç›¸å…³
  USER_PROFILE: (userId: string) => `user:${userId}:profile`,
  USER_STATS: (userId: string) => `user:${userId}:stats`,

  // æ–‡æ¡£ç›¸å…³
  DOCUMENT_PARSED: (docId: string) => `doc:${docId}:parsed`,
  DOCUMENT_CONTENT: (docId: string) => `doc:${docId}:content`,

  // ç¿»è¯‘ç›¸å…³
  TRANSLATION_TASK: (taskId: string) => `trans:${taskId}:task`,
  TRANSLATION_SEGMENTS: (taskId: string) => `trans:${taskId}:segments`,

  // æœ¯è¯­åº“ç›¸å…³
  TERMINOLOGY_BASE: (baseId: string) => `term:${baseId}:base`,
  TERMINOLOGY_TERMS: (baseId: string) => `term:${baseId}:terms`,
  TERMINOLOGY_MATCHES: (baseId: string, text: string) =>
    `term:${baseId}:matches:${hashText(text)}`,

  // LLMé…é¢ç›¸å…³
  LLM_USAGE: (provider: string, month: string) =>
    `llm:${provider}:usage:${month}`,

  // Sessionç›¸å…³
  SESSION: (sessionId: string) => `session:${sessionId}`,
};

// services/cache.service.ts
@Injectable()
export class CacheService {
  constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}

  async get<T>(key: string): Promise<T | undefined> {
    return this.cacheManager.get<T>(key);
  }

  async set<T>(key: string, value: T, ttl?: number): Promise<void> {
    await this.cacheManager.set(key, value, ttl || 3600000); // ms
  }

  async del(key: string): Promise<void> {
    await this.cacheManager.del(key);
  }

  async delPattern(pattern: string): Promise<void> {
    // åˆ é™¤åŒ¹é…patternçš„æ‰€æœ‰é”®
    const keys = await this.cacheManager.store.keys(`${pattern}*`);
    for (const key of keys) {
      await this.cacheManager.del(key);
    }
  }

  // ç¼“å­˜ç©¿é€ä¿æŠ¤
  async getOrFetch<T>(
    key: string,
    fetcher: () => Promise<T>,
    ttl?: number
  ): Promise<T> {
    let value = await this.get<T>(key);
    if (value) return value;

    // è·å–å€¼
    value = await fetcher();

    // ç¼“å­˜ï¼Œç©ºå€¼ç¼“å­˜è¾ƒçŸ­æ—¶é—´é˜²æ­¢ç©¿é€
    const cacheTtl = value ? (ttl || 3600000) : 600000; // ç©ºå€¼10åˆ†é’Ÿ
    await this.set(key, value || null, cacheTtl);

    return value;
  }

  // ç¼“å­˜é›ªå´©é˜²æŠ¤ï¼ˆåŠ å…¥éšæœºåç§»ï¼‰
  async setWithJitter<T>(
    key: string,
    value: T,
    baseTtl: number
  ): Promise<void> {
    const jitter = Math.random() * 0.1 * baseTtl; // 10%éšæœº
    await this.set(key, value, baseTtl + jitter);
  }
}

// ç¼“å­˜å¤±æ•ˆç­–ç•¥
export class CacheInvalidationStrategy {
  static invalidateOnUpdate(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const result = await originalMethod.apply(this, args);

      // æ ¹æ®æ“ä½œç±»å‹å¤±æ•ˆç¼“å­˜
      if (propertyKey.includes('update') || propertyKey.includes('create')) {
        const entityId = args[0]?.id || args[1]?.id;
        // å¤±æ•ˆç›¸å…³ç¼“å­˜
      }

      return result;
    };
  }
}
```

### 3. æ–‡ä»¶å­˜å‚¨ - GCS/S3

```typescript
// config/storage.config.ts
export interface StorageConfig {
  provider: 'gcs' | 's3';
  bucket: string;
  region?: string;
  credentials: {
    projectId?: string;
    keyFilename?: string;
    accessKeyId?: string;
    secretAccessKey?: string;
  };
}

// services/storage.service.ts
@Injectable()
export class StorageService {
  private storage: Storage;

  constructor(private configService: ConfigService) {
    const provider = this.configService.get('STORAGE_PROVIDER', 'gcs');

    if (provider === 'gcs') {
      this.storage = new GCSStorage(
        this.configService.get('GCS_PROJECT_ID'),
        this.configService.get('GCS_KEY_FILE')
      );
    } else {
      this.storage = new S3Storage(
        this.configService.get('AWS_ACCESS_KEY_ID'),
        this.configService.get('AWS_SECRET_ACCESS_KEY'),
        this.configService.get('AWS_REGION')
      );
    }
  }

  async upload(
    file: Express.Multer.File,
    options?: UploadOptions
  ): Promise<UploadResult> {
    const key = this.generateKey(file.originalname, options);

    const result = await this.storage.upload({
      key,
      buffer: file.buffer,
      contentType: file.mimetype,
      metadata: {
        originalName: file.originalname,
        uploadedAt: new Date().toISOString(),
        ...options?.metadata,
      },
    });

    return {
      url: result.url,
      key,
      size: file.size,
      uploadedAt: new Date(),
    };
  }

  async download(key: string): Promise<Buffer> {
    return this.storage.download(key);
  }

  async delete(key: string): Promise<void> {
    await this.storage.delete(key);
  }

  private generateKey(originalName: string, options?: UploadOptions): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(7);
    const ext = originalName.split('.').pop();

    const path = options?.path || 'uploads';
    return `${path}/${timestamp}-${random}.${ext}`;
  }
}

// storage/gcs.storage.ts
export class GCSStorage implements IStorage {
  private bucket: Bucket;

  constructor(projectId: string, keyFilename: string) {
    const storage = new Storage({ projectId, keyFilename });
    this.bucket = storage.bucket(process.env.GCS_BUCKET!);
  }

  async upload(params: StorageParams): Promise<StorageResult> {
    const file = this.bucket.file(params.key);

    await file.save(params.buffer, {
      metadata: {
        contentType: params.contentType,
        metadata: params.metadata,
      },
    });

    // ç”Ÿæˆç­¾åURLï¼ˆ24å°æ—¶æœ‰æ•ˆï¼‰
    const [url] = await file.getSignedUrl({
      version: 'v4',
      action: 'read',
      expires: Date.now() + 24 * 60 * 60 * 1000,
    });

    return {
      url,
      key: params.key,
    };
  }

  async download(key: string): Promise<Buffer> {
    const file = this.bucket.file(key);
    const [buffer] = await file.download();
    return buffer;
  }

  async delete(key: string): Promise<void> {
    await this.bucket.file(key).delete();
  }
}

// storage/s3.storage.ts
export class S3Storage implements IStorage {
  private s3: AWS.S3;
  private bucket: string;

  constructor(accessKeyId: string, secretAccessKey: string, region: string) {
    this.s3 = new AWS.S3({
      accessKeyId,
      secretAccessKey,
      region,
    });
    this.bucket = process.env.AWS_S3_BUCKET!;
  }

  async upload(params: StorageParams): Promise<StorageResult> {
    const result = await this.s3.putObject({
      Bucket: this.bucket,
      Key: params.key,
      Body: params.buffer,
      ContentType: params.contentType,
      Metadata: params.metadata,
    }).promise();

    const url = this.s3.getSignedUrl('getObject', {
      Bucket: this.bucket,
      Key: params.key,
      Expires: 24 * 60 * 60, // 24å°æ—¶
    });

    return { url, key: params.key };
  }

  async download(key: string): Promise<Buffer> {
    const result = await this.s3.getObject({
      Bucket: this.bucket,
      Key: key,
    }).promise();

    return result.Body as Buffer;
  }

  async delete(key: string): Promise<void> {
    await this.s3.deleteObject({
      Bucket: this.bucket,
      Key: key,
    }).promise();
  }
}
```

---

## ç¬¬ä¸‰æ–¹é›†æˆ

### 1. LLM API é€‰æ‹©å¯¹æ¯”

| ç»´åº¦ | Gemini | Claude | GPT-4 |
|-----|--------|--------|-------|
| **å®šä»·** | $0.000125/è¾“å…¥K $0.000375/è¾“å‡ºK | $0.003/è¾“å…¥K $0.015/è¾“å‡ºK | $0.03/è¾“å…¥K $0.06/è¾“å‡ºK |
| **ä¸Šä¸‹æ–‡é•¿åº¦** | 1M tokens | 200K tokens | 128K tokens |
| **ç¿»è¯‘è´¨é‡** | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ |
| **å“åº”é€Ÿåº¦** | å¿« | ä¸­ç­‰ | ä¸­ç­‰ |
| **APIç¨³å®šæ€§** | è¾ƒå¥½ | å¾ˆå¥½ | å¾ˆå¥½ |
| **æˆæœ¬æ•ˆç›Š** | æœ€ä¼˜ | é«˜è´¨é‡é«˜æˆæœ¬ | é«˜æˆæœ¬ |
| **é€‚ç”¨åœºæ™¯** | å¤§é‡ç¿»è¯‘ä»»åŠ¡ | å¤æ‚/å­¦æœ¯ç¿»è¯‘ | é«˜ç«¯ç”¨æˆ· |

**æ¨èæ–¹æ¡ˆ**ï¼š
- **MVPé˜¶æ®µ**ï¼šä½¿ç”¨ Geminiï¼ˆæˆæœ¬æœ€ä½ï¼Œè´¨é‡å¯æ¥å—ï¼‰
- **Proç”¨æˆ·**ï¼šæä¾›Claudeé€‰é¡¹ï¼ˆè´¨é‡æ›´å¥½ï¼‰
- **ä¼ä¸šç”¨æˆ·**ï¼šæ”¯æŒGPT-4ï¼ˆæœ€é«˜è´¨é‡ï¼‰

### 2. è®¤è¯æ–¹æ¡ˆ - OAuth2

```typescript
// auth/oauth.strategy.ts
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import { Strategy as GithubStrategy } from 'passport-github2';

@Injectable()
export class GoogleOAuthStrategy extends PassportStrategy(GoogleStrategy) {
  constructor(
    private authService: AuthService,
    configService: ConfigService,
  ) {
    super({
      clientID: configService.get('GOOGLE_CLIENT_ID'),
      clientSecret: configService.get('GOOGLE_CLIENT_SECRET'),
      callbackURL: configService.get('GOOGLE_CALLBACK_URL'),
      scope: ['email', 'profile'],
    });
  }

  async validate(accessToken: string, refreshToken: string, profile: any) {
    const user = await this.authService.validateOAuthUser('google', profile);
    return {
      user,
      accessToken,
      refreshToken,
    };
  }
}

@Injectable()
export class GithubOAuthStrategy extends PassportStrategy(GithubStrategy) {
  constructor(
    private authService: AuthService,
    configService: ConfigService,
  ) {
    super({
      clientID: configService.get('GITHUB_CLIENT_ID'),
      clientSecret: configService.get('GITHUB_CLIENT_SECRET'),
      callbackURL: configService.get('GITHUB_CALLBACK_URL'),
      scope: ['user:email'],
    });
  }

  async validate(accessToken: string, refreshToken: string, profile: any) {
    const user = await this.authService.validateOAuthUser('github', profile);
    return {
      user,
      accessToken,
      refreshToken,
    };
  }
}

// controllers/auth.controller.ts
@Controller('api/v1/auth')
export class AuthController {
  @Post('register')
  async register(@Body() dto: RegisterDto) {
    return this.authService.register(dto);
  }

  @Post('login')
  async login(@Body() dto: LoginDto) {
    return this.authService.login(dto.email, dto.password);
  }

  @Get('oauth/google')
  @UseGuards(AuthGuard('google'))
  async googleAuth() {}

  @Get('oauth/google/callback')
  @UseGuards(AuthGuard('google'))
  googleAuthRedirect(@Req() req: Request) {
    const { user, accessToken, refreshToken } = req.user;

    // é‡å®šå‘å›å‰ç«¯ï¼Œæºå¸¦ä»¤ç‰Œ
    return `${this.configService.get('FRONTEND_URL')}/auth/callback?token=${accessToken}&refresh=${refreshToken}`;
  }

  @Get('oauth/github')
  @UseGuards(AuthGuard('github'))
  async githubAuth() {}

  @Get('oauth/github/callback')
  @UseGuards(AuthGuard('github'))
  githubAuthRedirect(@Req() req: Request) {
    const { user, accessToken, refreshToken } = req.user;
    return `${this.configService.get('FRONTEND_URL')}/auth/callback?token=${accessToken}&refresh=${refreshToken}`;
  }

  @Post('refresh-token')
  @UseGuards(AuthGuard('jwt'))
  async refreshToken(@Req() req: Request) {
    const user = req.user as JwtPayload;
    return this.authService.generateTokens(user);
  }
}
```

### 3. æ–‡æ¡£çˆ¬å– - Cheerio vs Puppeteer

| ç‰¹æ€§ | Cheerio | Puppeteer |
|------|---------|-----------|
| **ç”¨é€”** | é™æ€HTMLè§£æ | æµè§ˆå™¨è‡ªåŠ¨åŒ– |
| **æ€§èƒ½** | â­â­â­â­â­ è¶…å¿« | â­â­ è¾ƒæ…¢ |
| **å†…å­˜å ç”¨** | â­â­â­â­â­ ä½ | â­â­ é«˜ |
| **JavaScriptæ¸²æŸ“** | âŒ ä¸æ”¯æŒ | âœ… æ”¯æŒ |
| **å¤§è§„æ¨¡çˆ¬å–** | âœ… æ¨è | âŒ ä¸æ¨è |
| **å¤æ‚äº¤äº’** | âŒ ä¸è¡Œ | âœ… å¯ä»¥ |

**ä½¿ç”¨ç­–ç•¥**ï¼š

```typescript
// services/url-fetcher.service.ts
@Injectable()
export class UrlFetcherService {
  async fetchAndParse(
    url: string,
    options: FetchOptions
  ): Promise<ParsedDocument> {
    // ç¬¬ä¸€æ­¥ï¼šæ£€æµ‹æ˜¯å¦éœ€è¦JSæ¸²æŸ“
    const requiresJS = await this.checkIfRequiresJS(url);

    let html: string;

    if (requiresJS) {
      // ä½¿ç”¨ Puppeteer å¤„ç†åŠ¨æ€å†…å®¹
      html = await this.fetchWithPuppeteer(url);
    } else {
      // ä½¿ç”¨ Cheerio å¤„ç†é™æ€HTMLï¼ˆå¿«é€Ÿï¼‰
      html = await this.fetchWithCheerio(url);
    }

    // è§£æHTML
    const parsed = await this.parseHTML(html);

    return parsed;
  }

  private async checkIfRequiresJS(url: string): Promise<boolean> {
    try {
      const response = await axios.get(url, {
        timeout: 5000,
      });

      const html = response.data;

      // æ£€æŸ¥æ˜¯å¦åŒ…å«å¤§é‡JSæ¡†æ¶è¿¹è±¡
      const reactPattern = /react|vue|angular|nextjs|nuxt/i;
      const jsFrameworks = html.match(reactPattern);

      // æ£€æŸ¥æ˜¯å¦å†…å®¹ä¸ºç©ºï¼ˆå…¸å‹çš„CSRè¿¹è±¡ï¼‰
      const contentLength = html.replace(/<[^>]*>/g, '').trim().length;

      return jsFrameworks !== null && contentLength < 500;
    } catch {
      // å‡ºé”™æ—¶é»˜è®¤ä½¿ç”¨Puppeteerï¼ˆæ›´ä¿é™©ï¼‰
      return true;
    }
  }

  private async fetchWithCheerio(url: string): Promise<string> {
    const response = await axios.get(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 ...',
      },
      timeout: 10000,
    });

    return response.data;
  }

  private async fetchWithPuppeteer(url: string): Promise<string> {
    const browser = await puppeteer.launch({
      headless: 'new',
      args: ['--no-sandbox'],
    });

    try {
      const page = await browser.newPage();

      // è®¾ç½®è§†å£å’Œç”¨æˆ·ä»£ç†
      await page.setViewport({ width: 1280, height: 720 });
      await page.setUserAgent('Mozilla/5.0 ...');

      // å¯¼èˆªå¹¶ç­‰å¾…åŠ è½½
      await page.goto(url, {
        waitUntil: 'networkidle2',
        timeout: 30000,
      });

      // è·å–æ¸²æŸ“åçš„HTML
      const html = await page.content();

      await page.close();
      return html;
    } finally {
      await browser.close();
    }
  }

  private async parseHTML(html: string): Promise<ParsedDocument> {
    const $ = cheerio.load(html);

    // ç§»é™¤è„šæœ¬å’Œæ ·å¼
    $('script, style').remove();

    const title = $('title').text() || $('h1').first().text();
    const content = this.extractMainContent($);

    return {
      title,
      content,
      segments: this.segmentContent(content),
    };
  }
}

// ä½¿ç”¨åœºæ™¯åˆ¤æ–­
const urlFetchStrategy = {
  // é™æ€ç½‘ç«™ â†’ Cheerio
  'medium.com': 'cheerio',          // âŒ ä½†Mediumé€šè¿‡JSåŠ è½½ï¼Œéœ€æ£€æµ‹
  'github.com': 'cheerio',          // âœ… é™æ€
  'wikipedia.org': 'cheerio',       // âœ… é™æ€

  // åŠ¨æ€ç½‘ç«™ â†’ Puppeteer
  'example.com/spa': 'puppeteer',   // âœ… React SPA
  'medium.com/stories': 'puppeteer', // âœ… åŠ¨æ€åŠ è½½
  'app.example.com': 'puppeteer',   // âœ… Webåº”ç”¨
};
```

---

## å¼€å‘ä¼˜å…ˆçº§å’Œé‡Œç¨‹ç¢‘

### Phase 1: MVP (6å‘¨)

**ç›®æ ‡**ï¼šæ ¸å¿ƒç¿»è¯‘åŠŸèƒ½å¯ç”¨

#### Week 1-2: åŸºç¡€è®¾æ–½å’Œè®¤è¯
- [ ] Next.js é¡¹ç›®åˆå§‹åŒ–ï¼ˆå‰ç«¯æ¡†æ¶ã€è·¯ç”±ã€å¸ƒå±€ï¼‰
- [ ] Nest.js é¡¹ç›®åˆå§‹åŒ–ï¼ˆåç«¯æ¡†æ¶ã€æ•°æ®åº“è¿æ¥ï¼‰
- [ ] PostgreSQL æ•°æ®åº“å»ºè¡¨
- [ ] ç”¨æˆ·è®¤è¯ï¼ˆæ³¨å†Œã€ç™»å½•ã€JWTï¼‰
- [ ] OAuth é›†æˆï¼ˆGoogleç™»å½•ï¼‰

#### Week 3: å‰ç«¯ç¼–è¾‘å™¨UI
- [ ] å®ç° DualPaneEditor åŸºç¡€ç»„ä»¶
- [ ] æ–‡ä»¶ä¸Šä¼ ç»„ä»¶
- [ ] åŸºç¡€æ ·å¼ï¼ˆTailwind + shadcn/uiï¼‰
- [ ] çŠ¶æ€ç®¡ç†ï¼ˆZustandï¼‰

#### Week 4: åç«¯æ–‡æ¡£è§£æ
- [ ] å®ç° DocumentParsingService
- [ ] æ”¯æŒæ ¼å¼ï¼šHTMLã€Markdownã€PDFåŸºç¡€
- [ ] æ–‡æœ¬åˆ†å‰²ï¼ˆæ®µè½çº§åˆ«ï¼‰
- [ ] æ–‡ä»¶ä¸Šä¼ åˆ°GCS/S3

#### Week 5: AIç¿»è¯‘é›†æˆ
- [ ] é€‰æ‹© Gemini ä½œä¸ºåˆå§‹æä¾›å•†
- [ ] å®ç° AITranslationService
- [ ] å•æ®µè½ç¿»è¯‘åŠŸèƒ½
- [ ] WebSocket æµå¼ç¿»è¯‘

#### Week 6: è”è°ƒå’Œä¼˜åŒ–
- [ ] å‰åç«¯è”è°ƒ
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] é”™è¯¯å¤„ç†å’Œæ—¥å¿—
- [ ] åŸºç¡€æµ‹è¯•

**äº¤ä»˜ç‰©**ï¼š
- å¯ä¸Šä¼ æ–‡æ¡£ã€ç¿»è¯‘å•ç¯‡æ–‡ç« çš„å·¥ä½œåŸå‹
- æ”¯æŒ2-3ç§æ–‡æ¡£æ ¼å¼
- ç¿»è¯‘è´¨é‡å¯æ¥å—ï¼ˆGeminiï¼‰

---

### Phase 2: æ ¸å¿ƒåŠŸèƒ½å®Œå–„ (6å‘¨)

#### Week 7-8: æœ¯è¯­åº“ç³»ç»Ÿ
- [ ] TerminologyService å®Œæ•´å®ç°
- [ ] æœ¯è¯­åº“UIï¼ˆç®¡ç†ã€å¯¼å…¥ã€å¯¼å‡ºï¼‰
- [ ] æœ¯è¯­åŒ¹é…å’Œæ³¨å…¥æç¤ºè¯

#### Week 9: ç¿»è¯‘å†å²å’Œç‰ˆæœ¬ç®¡ç†
- [ ] TranslationHistoryService
- [ ] å†å²è®°å½•UI
- [ ] æ¯”è¾ƒè§†å›¾åŠŸèƒ½

#### Week 10: å¤šLLMæ”¯æŒ
- [ ] Claude é›†æˆ
- [ ] GPT-4 é›†æˆ
- [ ] LLMé€‰æ‹©å™¨UI
- [ ] æˆæœ¬ä¼°è®¡

#### Week 11: æ–‡æ¡£ç®¡ç†
- [ ] å®Œæ•´æ–‡æ¡£æ ¼å¼æ”¯æŒï¼ˆWordã€LaTeXï¼‰
- [ ] æ–‡æ¡£é¢„è§ˆåŠŸèƒ½
- [ ] æ–‡æ¡£åˆ—è¡¨å’Œæœç´¢

#### Week 12: æ€§èƒ½ä¼˜åŒ–å’Œæµ‹è¯•
- [ ] ç¼“å­˜ç­–ç•¥éƒ¨ç½²ï¼ˆRedisï¼‰
- [ ] è™šæ‹Ÿæ»šåŠ¨æ”¯æŒå¤§æ–‡æ¡£
- [ ] å•å…ƒæµ‹è¯•å’ŒE2Eæµ‹è¯•

**äº¤ä»˜ç‰©**ï¼š
- å®Œæ•´çš„ç¿»è¯‘å·¥ä½œæµ
- æœ¯è¯­åº“ç®¡ç†
- å¤šLLMæ”¯æŒ

---

### Phase 3: ä¼ä¸šçº§åŠŸèƒ½ (4å‘¨)

#### Week 13: ç”¨æˆ·ç®¡ç†å’Œæƒé™
- [ ] è§’è‰²åŸºè®¿é—®æ§åˆ¶ï¼ˆRBACï¼‰
- [ ] å›¢é˜Ÿå…±äº«åŠŸèƒ½
- [ ] å®¡è®¡æ—¥å¿—

#### Week 14: è®¢é˜…å’Œè®¡è´¹
- [ ] å®šä»·å±‚è®¾è®¡ï¼ˆFree/Pro/Enterpriseï¼‰
- [ ] Stripe é›†æˆ
- [ ] é¢åº¦ç®¡ç†å’Œé™æµ

#### Week 15: é«˜çº§åˆ†æ
- [ ] ç¿»è¯‘æˆæœ¬åˆ†æ
- [ ] ä½¿ç”¨ç»Ÿè®¡
- [ ] ä»ªè¡¨æ¿

#### Week 16: éƒ¨ç½²å’Œä¼˜åŒ–
- [ ] Docker å®¹å™¨åŒ–
- [ ] K8s éƒ¨ç½²é…ç½®
- [ ] ç›‘æ§å’Œå‘Šè­¦ï¼ˆDatadog/New Relicï¼‰

**äº¤ä»˜ç‰©**ï¼š
- ç”Ÿäº§çº§ç³»ç»Ÿ
- ä¼ä¸šçº§åŠŸèƒ½å®Œæ•´

---

### ä¼˜å…ˆçº§çŸ©é˜µ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ä¼˜å…ˆçº§ vs å·¥ä½œé‡çŸ©é˜µ                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                    HIGH  â”‚
â”‚                                                   EFFORT â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  å¤šLLMæ”¯æŒ  â”‚                   â”‚ ä¼ä¸šçº§æƒé™   â”‚    â”‚
â”‚  â”‚   (ä¸­ä¼˜å…ˆ)   â”‚                   â”‚  (ä½ä¼˜å…ˆ)    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                         â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  LOW    â”‚  æ–‡æ¡£æ ¼å¼æ”¯æŒ  æœ¯è¯­åº“  ç‰ˆæœ¬ç®¡ç†  â”‚    LOW     â”‚
â”‚ EFFORT  â”‚      (é«˜ä¼˜å…ˆ)   (ä¸­)   (ä¸­)     â”‚   BENEFIT  â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ åŒæ ç¼–è¾‘å™¨UI     â”‚      â”‚  å†å²è®°å½•    â”‚            â”‚
â”‚  â”‚  (æœ€é«˜ä¼˜å…ˆçº§)     â”‚      â”‚ (ä¸­ä¼˜å…ˆçº§)   â”‚            â”‚
â”‚  â”‚ JWTè®¤è¯ ä¸Šä¼  ç¿»è¯‘ â”‚      â”‚              â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   LOW EFFORT                              HIGH EFFORT
   HIGH BENEFIT                            LOW BENEFIT
```

---

## æŠ€æœ¯é£é™©å’Œè§£å†³æ–¹æ¡ˆ

### 1. LLM API æˆæœ¬é£é™©

**é£é™©**ï¼šç¿»è¯‘å¤§é‡æ–‡æ¡£å¯¼è‡´APIæˆæœ¬çˆ†å¢

**è§£å†³æ–¹æ¡ˆ**ï¼š
```typescript
// services/cost-control.service.ts
@Injectable()
export class CostControlService {
  // 1. ç¼“å­˜ç¿»è¯‘ç»“æœ
  async cacheTranslation(
    sourceText: string,
    targetLanguage: string,
    translation: string
  ) {
    const key = this.hashKey(sourceText, targetLanguage);
    await this.redis.set(key, translation, 7 * 24 * 60 * 60); // 7å¤©
  }

  // 2. æ‰¹å¤„ç†è¯·æ±‚ï¼ˆå‡å°‘APIè°ƒç”¨æ¬¡æ•°ï¼‰
  async batchTranslate(segments: TextSegment[], config: TranslationConfig) {
    // åˆ†ç»„å¤„ç†ï¼Œæ¯æ‰¹æœ€å¤š20ä¸ªæ®µè½
    const batchSize = 20;
    for (let i = 0; i < segments.length; i += batchSize) {
      const batch = segments.slice(i, i + batchSize);
      await this.aiService.translateBatch(batch, config);
    }
  }

  // 3. é…é¢ç®¡ç†
  async checkQuota(userId: string, provider: string): Promise<boolean> {
    const user = await this.userService.findById(userId);
    const monthlyKey = `${provider}:${new Date().toISOString().slice(0, 7)}`;
    const usage = await this.redis.get(`usage:${userId}:${monthlyKey}`);

    return (usage || 0) < user.monthlyLimit;
  }

  // 4. æˆæœ¬é¢„ä¼°å’Œæç¤º
  async estimateAndWarn(
    segments: TextSegment[],
    provider: string
  ): Promise<EstimatedCost> {
    const estimator = this.getEstimator(provider);
    const totalCost = segments.reduce((sum, seg) =>
      sum + estimator.estimate(seg.sourceText), 0
    );

    if (totalCost > WARNING_THRESHOLD) {
      // å‘é€é€šçŸ¥ç»™ç”¨æˆ·
      await this.notificationService.sendWarning({
        userId: currentUser.id,
        message: `é¢„ä¼°è´¹ç”¨ $${totalCost}ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ`,
      });
    }

    return { totalCost, breakdown: estimator.breakdown(segments) };
  }

  // 5. æ™ºèƒ½æä¾›å•†é€‰æ‹©
  async selectOptimalProvider(
    segments: TextSegment[],
    preferences: { quality: number; costSensitive: number }
  ): Promise<string> {
    const providers = ['gemini', 'claude', 'gpt4'];

    const scores = providers.map(p => ({
      provider: p,
      cost: this.estimateCost(segments, p),
      quality: this.getQualityScore(p),
      score: this.calculateScore(p, preferences),
    }));

    return scores.sort((a, b) => b.score - a.score)[0].provider;
  }
}
```

### 2. æ–‡æ¡£è§£æå¤±è´¥é£é™©

**é£é™©**ï¼šå¤æ‚PDFæˆ–ç‰¹æ®Šæ ¼å¼å¯¼è‡´è§£æå¤±è´¥

**è§£å†³æ–¹æ¡ˆ**ï¼š
```typescript
// å¤šç­–ç•¥é™çº§
async parseDocumentWithFallback(
  file: Buffer,
  format: string
): Promise<ParsedDocument> {
  const strategies = [
    new NativeStrategy(),      // åŸç”Ÿè§£æ
    new OCRStrategy(),         // å›¾æ–‡è¯†åˆ«ï¼ˆif PDFæ— å¯æå–æ–‡æœ¬ï¼‰
    new ManualReviewStrategy(), // æ‰‹åŠ¨å®¡æŸ¥é˜Ÿåˆ—
  ];

  for (const strategy of strategies) {
    try {
      return await strategy.parse(file, format);
    } catch (error) {
      logger.warn(`Strategy ${strategy.name} failed:`, error);
      continue;
    }
  }

  // éƒ½å¤±è´¥åˆ™ä¸ŠæŠ¥
  throw new DocumentParsingFailedError(file.originalname);
}

// OCR é™çº§å¤„ç†
class OCRStrategy {
  async parse(file: Buffer, format: string): Promise<ParsedDocument> {
    if (format !== 'pdf') throw new Error('Only PDF supported');

    // ä½¿ç”¨ Tesseract è¿›è¡ŒOCR
    const pages = await extractPDFPages(file);
    const textPages = [];

    for (const page of pages) {
      const text = await recognizeText(page);
      textPages.push(text);
    }

    return {
      title: 'OCR Extracted Document',
      content: textPages.join('\n\n'),
      metadata: { extractedViaOCR: true },
    };
  }
}
```

### 3. ç¿»è¯‘è´¨é‡é£é™©

**é£é™©**ï¼šAIç¿»è¯‘å­˜åœ¨é”™è¯¯ã€æœ¯è¯­ä¸ä¸€è‡´

**è§£å†³æ–¹æ¡ˆ**ï¼š
```typescript
// ç¿»è¯‘è´¨é‡æ£€æŸ¥
@Injectable()
export class TranslationQualityService {
  // 1. è‡ªåŠ¨è´¨é‡è¯„åˆ†
  async scoreTranslation(
    sourceText: string,
    targetText: string,
    sourceLanguage: string,
    targetLanguage: string
  ): Promise<QualityScore> {
    const scores = {
      completeness: await this.checkCompleteness(sourceText, targetText),
      terminology: await this.checkTerminologyConsistency(targetText),
      grammar: await this.checkGrammar(targetText, targetLanguage),
      formatting: this.checkFormattingPreservation(sourceText, targetText),
      overall: 0,
    };

    scores.overall = (
      scores.completeness * 0.3 +
      scores.terminology * 0.3 +
      scores.grammar * 0.2 +
      scores.formatting * 0.2
    );

    return scores;
  }

  // 2. å¤šæ¨¡å‹éªŒè¯
  async validateWithMultipleModels(
    text: string,
    targetLanguage: string
  ): Promise<ValidationResult> {
    const providers = ['gemini', 'claude'];
    const translations = {};

    for (const provider of providers) {
      translations[provider] = await this.aiService.translate(
        text, { provider, targetLanguage }
      );
    }

    // æ¯”è¾ƒç¿»è¯‘ç»“æœçš„ç›¸ä¼¼åº¦
    const similarity = this.calculateSimilarity(
      translations.gemini,
      translations.claude
    );

    return {
      primaryTranslation: translations.gemini,
      alternativeTranslations: translations,
      confidence: similarity, // é«˜ç›¸ä¼¼åº¦ = é«˜ç½®ä¿¡åº¦
    };
  }

  // 3. äººå·¥å®¡æŸ¥é˜Ÿåˆ—
  async flagForHumanReview(
    segmentId: string,
    reason: string,
    qualityScore: number
  ) {
    if (qualityScore < REVIEW_THRESHOLD) {
      await this.reviewQueueService.add({
        segmentId,
        reason,
        priority: 'high',
      });
    }
  }

  // 4. ç”¨æˆ·åé¦ˆå¾ªç¯
  async collectFeedback(
    translationId: string,
    segmentId: string,
    feedback: TranslationFeedback
  ) {
    await this.feedbackService.save(feedback);

    // ç”¨äºæ”¹è¿›æç¤ºè¯
    if (feedback.quality === 'poor') {
      await this.promptOptimizationService.recordFailure(feedback);
    }
  }
}
```

### 4. å¹¶å‘å’Œæ‰©å±•æ€§é£é™©

**é£é™©**ï¼šé«˜å¹¶å‘ç¿»è¯‘è¯·æ±‚å¯¼è‡´ç³»ç»Ÿè¿‡è½½

**è§£å†³æ–¹æ¡ˆ**ï¼š
```typescript
// services/translation-queue.service.ts
@Injectable()
export class TranslationQueueService {
  private queue: BullQueue<TranslationJob>;

  constructor() {
    this.queue = new Queue('translations', {
      connection: redis,
      defaultJobOptions: {
        attempts: 3,
        backoff: { type: 'exponential', delay: 2000 },
      },
    });

    // å¹¶å‘æ§åˆ¶ï¼šæœ€å¤šåŒæ—¶å¤„ç†5ä¸ª
    this.queue.process(5, this.processTranslation.bind(this));
  }

  async submitTranslation(
    taskId: string,
    segments: TextSegment[]
  ): Promise<JobId> {
    return this.queue.add(
      {
        taskId,
        segments,
        priority: this.calculatePriority(segments),
      },
      {
        priority: this.calculatePriority(segments),
        delay: 0,
      }
    );
  }

  private async processTranslation(job: Job<TranslationJob>) {
    // æ›´æ–°è¿›åº¦
    await job.updateProgress(0);

    const { taskId, segments } = job.data;
    const batchSize = 10;

    for (let i = 0; i < segments.length; i += batchSize) {
      const batch = segments.slice(i, i + batchSize);

      try {
        await this.aiService.translateBatch(batch);

        const progress = Math.min(100, ((i + batchSize) / segments.length) * 100);
        await job.updateProgress(progress);
      } catch (error) {
        throw error; // è‡ªåŠ¨é‡è¯•
      }
    }

    return { taskId, status: 'completed' };
  }

  private calculatePriority(segments: TextSegment[]): number {
    // çŸ­æ–‡æ¡£ä¼˜å…ˆå¤„ç†
    return segments.length < 100 ? 10 : 5;
  }
}

// é™æµ
@Injectable()
export class RateLimitingService {
  async checkRateLimit(userId: string, provider: string): Promise<boolean> {
    const key = `ratelimit:${userId}:${provider}`;
    const current = await this.redis.incr(key);

    if (current === 1) {
      // é¦–æ¬¡è¯·æ±‚ï¼Œè®¾ç½®è¿‡æœŸæ—¶é—´
      await this.redis.expire(key, 60); // 60ç§’å†…æœ€å¤š100ä¸ªè¯·æ±‚
    }

    return current <= 100;
  }
}
```

### 5. æ•°æ®å®‰å…¨å’Œéšç§é£é™©

**é£é™©**ï¼šç”¨æˆ·æ–‡æ¡£å’Œç¿»è¯‘å†…å®¹å¯èƒ½æ³„éœ²

**è§£å†³æ–¹æ¡ˆ**ï¼š
```typescript
// åŠ å¯†ç­–ç•¥
@Injectable()
export class EncryptionService {
  // æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
  async encryptSensitiveContent(
    content: string,
    userId: string
  ): Promise<string> {
    const encryptionKey = await this.deriveKeyFromUserId(userId);
    return this.encrypt(content, encryptionKey);
  }

  // ä¼ è¾“åŠ å¯†
  setupTLS() {
    // æ‰€æœ‰APIä½¿ç”¨HTTPS
    // WebSocketä½¿ç”¨WSS
  }

  // å®¡è®¡æ—¥å¿—
  async logAccessToDocument(userId: string, documentId: string) {
    await this.auditLogService.log({
      action: 'DOCUMENT_ACCESS',
      userId,
      documentId,
      timestamp: new Date(),
      ipAddress: getClientIp(),
    });
  }
}

// æ•°æ®éšç§
@Injectable()
export class PrivacyService {
  // æ•°æ®æœ€å°åŒ–
  async getDocumentForTranslation(
    userId: string,
    documentId: string
  ): Promise<DocumentForTranslation> {
    // åªè¿”å›å¿…è¦çš„å­—æ®µ
    return {
      id: documentId,
      segments: [...],
      // âŒ ä¸è¿”å›ï¼šuserId, uploadedAt, metadataç­‰éå¿…éœ€å­—æ®µ
    };
  }

  // å®šæœŸæ¸…ç†
  async deleteOldTranslationHistory(daysToKeep: number = 90) {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

    await this.historyRepo.delete({
      createdAt: LessThan(cutoffDate),
      visibility: 'private', // ä»…åˆ é™¤ç§æœ‰è®°å½•
    });
  }

  // GDPRåˆè§„
  async exportUserData(userId: string): Promise<UserDataExport> {
    return {
      user: await this.userService.findById(userId),
      documents: await this.documentService.findByUserId(userId),
      translations: await this.translationService.findByUserId(userId),
      terminology: await this.terminologyService.findByUserId(userId),
    };
  }

  async deleteUserData(userId: string) {
    // çº§è”åˆ é™¤æ‰€æœ‰ç”¨æˆ·æ•°æ®
    await this.userService.delete(userId);
  }
}
```

### 6. ç›‘æ§å’Œå‘Šè­¦

```typescript
// monitoring/metrics.ts
import { Histogram, Counter, Gauge } from 'prom-client';

export const metrics = {
  // ç¿»è¯‘æ€§èƒ½
  translationDuration: new Histogram({
    name: 'translation_duration_seconds',
    help: 'Translation processing time',
    buckets: [1, 5, 10, 30, 60],
    labelNames: ['provider', 'language_pair'],
  }),

  // API å»¶è¿Ÿ
  apiLatency: new Histogram({
    name: 'api_latency_ms',
    help: 'API response time',
    buckets: [10, 50, 100, 500, 1000],
    labelNames: ['endpoint', 'method'],
  }),

  // é”™è¯¯ç‡
  translationErrors: new Counter({
    name: 'translation_errors_total',
    help: 'Total translation errors',
    labelNames: ['provider', 'error_type'],
  }),

  // æˆæœ¬è¿½è¸ª
  translationCost: new Counter({
    name: 'translation_cost_total',
    help: 'Total translation cost in USD',
    labelNames: ['provider'],
  }),

  // å¹¶å‘æ•°
  activeTranslations: new Gauge({
    name: 'active_translations',
    help: 'Currently active translation tasks',
  }),
};

// å‘Šè­¦è§„åˆ™
export const alertRules = [
  {
    name: 'HighErrorRate',
    query: 'rate(translation_errors_total[5m]) > 0.05',
    severity: 'critical',
  },
  {
    name: 'HighLatency',
    query: 'histogram_quantile(0.95, api_latency_ms) > 1000',
    severity: 'warning',
  },
  {
    name: 'HighCost',
    query: 'rate(translation_cost_total[1h]) > 100',
    severity: 'info',
  },
];
```

---

## æ€»ç»“å’Œå»ºè®®

### æ ¸å¿ƒæ¶æ„ä¼˜åŠ¿

âœ… **æ¨¡å—åŒ–è®¾è®¡**ï¼šå‰åç«¯è§£è€¦ï¼Œä¾¿äºæ‰©å±•
âœ… **å¤šLLMæ”¯æŒ**ï¼šçµæ´»é€‰æ‹©ï¼Œæˆæœ¬å¯æ§
âœ… **å¯æ‰©å±•ç¼“å­˜**ï¼šRedisç¼“å­˜å‡å°‘APIè°ƒç”¨
âœ… **å®Œæ•´æƒé™ä½“ç³»**ï¼šæ”¯æŒå¤šç§Ÿæˆ·å’Œå›¢é˜Ÿåä½œ
âœ… **ç”Ÿäº§å°±ç»ª**ï¼šæ—¥å¿—ã€ç›‘æ§ã€å‘Šè­¦å®Œå¤‡

### ç«‹å³è¡ŒåŠ¨é¡¹

1. **ç¡®è®¤LLMé€‰æ‹©**ï¼šä¸å›¢é˜Ÿè®¨è®ºé€‰æ‹©Gemini/Claude/GPT-4
2. **ç¯å¢ƒå‡†å¤‡**ï¼šç”³è¯·GCP/AWSè´¦å·ï¼Œè·å–APIå¯†é’¥
3. **å›¢é˜Ÿåˆ†å·¥**ï¼šå‰ç«¯2äººã€åç«¯2äººã€DevOps1äºº
4. **é¡¹ç›®ç®¡ç†**ï¼šä½¿ç”¨GitHub Projectsæˆ–Jiraè¿›è¡Œè¿›åº¦è¿½è¸ª

### æŠ€æœ¯å€ºåŠ¡ç®¡ç†

- Week 4: å»ºç«‹å•å…ƒæµ‹è¯•æ¡†æ¶
- Week 8: æ€§èƒ½åŸºå‡†æµ‹è¯•
- Week 12: å®‰å…¨å®¡è®¡
- Week 16: æŠ€æœ¯æ–‡æ¡£å®Œæ•´åŒ–

### ä¸‹ä¸€æ­¥

1. åˆ›å»º GitHub é¡¹ç›®å’ŒIssueæ¨¡æ¿
2. å»ºç«‹å‰åç«¯å¼€å‘è§„èŒƒæ–‡æ¡£
3. å‡†å¤‡å¼€å‘ç¯å¢ƒå’ŒCI/CDæµç¨‹
4. è¿›è¡ŒæŠ€æœ¯é€‰å‹æœ€ç»ˆç¡®è®¤
